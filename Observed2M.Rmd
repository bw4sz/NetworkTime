---
title: "Observed Data"
author: "Ben Weinstein - Stony Brook University"
output:
  html_document:
    toc: true
    number_sections: true
    theme: spacelab
    keep_md: true
  word_document: default
---

```{r,warning=FALSE,message=FALSE,echo=FALSE,cache=FALSE}
library(reshape2)
library(BEST)

library(foreach)
library(doSNOW)
library(chron)
library(ggplot2)
library(knitr)
library(R2jags)
library(dplyr)
library(stringr)
library(gridExtra)
library(boot)
library(picante)
library(bipartite)

opts_chunk$set(message=FALSE,warning=FALSE,fig.width=5,fig.height=4,echo=TRUE,cache=F,fig.align='center',fig.path="figureObserved/")

set.seed(3)
#source functions

source("Bayesian/BayesFunctions.R")
```

```{r,echo=F,cache=FALSE}
paste("Run Completed at",Sys.time())
```

```{r}
#reload if needed
#load("Observed.Rdata")
```

#Observed dataset

```{r}
#read in flower morphology data, comes from Nectar.R
droppath<-"C:/Users/Ben/Dropbox/"
fl.morph<-read.csv(paste(droppath,"Thesis/Maquipucuna_SantaLucia/Results/FlowerMorphology.csv",sep=""))

#First row is empty
fl.morph<-fl.morph[-1,]

#Bring in Hummingbird Morphology Dataset, comes from
hum.morph<-read.csv(paste(droppath,"Thesis/Maquipucuna_SantaLucia/Results/HummingbirdMorphology.csv",sep=""))

#Bring in Interaction Matrix
int<-read.csv(paste(droppath,"Thesis/Maquipucuna_SantaLucia/Results/Network/HummingbirdInteractions.csv",sep=""),row.names=1)

#one date error
int[int$DateP %in% '2013-07-25',"Month"]<-7

#Correct known taxonomic disagreements, atleast compared to traits
int[int$Iplant_Double=="Alloplectus purpureus","Iplant_Double"]<-"Glossoloma purpureum"
int[int$Iplant_Double=="Capanea affinis","Iplant_Double"]<-"Kohleria affinis"
int[int$Iplant_Double=="Columnea cinerea","Iplant_Double"]<-"Columnea mastersonii"
int[int$Iplant_Double=="Alloplectus teuscheri","Iplant_Double"]<-"Drymonia teuscheri"
int[int$Iplant_Double=="Drymonia collegarum","Iplant_Double"]<-"Alloplectus tetragonoides"

#Some reasonable level of presences, 25 points
keep<-names(which(table(int$Hummingbird) > 20))

int<-int[int$Hummingbird %in% keep,]

m.dat<-droplevels(int[colnames(int) %in% c("ID","Video","Time","Hummingbird","Sex","TransectID","Transect_R","Iplant_Double","Pierce","DateP","Month","ele","Type")])

#Does the data come from camera or transect?
m.dat$Type<-(is.na(m.dat$TransectID))*1

m.dat$Year<-years(as.Date(m.dat$DateP))
#one missing date
m.dat$Year[m.dat$Year %in% 2012]<-2013

#Number of bird species
h_species<-nlevels(m.dat$Hummingbird)

#Number of plant species
plant_species<-nlevels(m.dat$Iplant_Double)

#Get english name
dath<-merge(m.dat,hum.morph, by.x="Hummingbird",by.y="English",keep=all)

#Merge to flowers
int.FLlevels<-levels(factor(dath$Iplant_Double))

#Which flowers are we missing info for?
missingTraits<-int.FLlevels[!int.FLlevels %in% fl.morph$X]

#print(paste("Missing Trait Information:",missingTraits))
dath<-merge(dath,fl.morph, by.x="Iplant_Double",by.y="X")

#Drop piercing events, since they don't represent correlation
dath<-dath[!dath$Pierce %in% c("y","Y"),]
```

##Match Species to Morphology

```{r}
#remove species with less than  10 observations
keep<-names(which(table(dath$Hummingbird) > 20))

dath<-droplevels(dath[dath$Hummingbird %in% keep,])

#observed traitmatching
traitmatchF<-abs(t(sapply(hum.morph$Bill,function(x){x-fl.morph$TotalCorolla})))

rownames(traitmatchF)<-hum.morph$English
colnames(traitmatchF)<-fl.morph$Group.1
```

```{r}
#match names #Round to 2 decimals #Convert to cm for winbugs, avoids numerical underflow
traitmatchT<-round(traitmatchF[rownames(traitmatchF) %in% dath$Hummingbird,colnames(traitmatchF) %in% dath$Iplant_Double],2)/10

traitmatchT<-traitmatchT[sort(rownames(traitmatchT)),sort(colnames(traitmatchT))]
```

##Elevation ranges

Create a binary variable whether each observation was in a low elevation or high elevation transect. We have some species that just occur at the top of the gradient, and are not present in the sampling window of flowers at the low elevation.

Accounting for non-availability.
We have to figure out which plants were sampled in which periods, and if it was sampled, the non-detection are 0 if it wasn't the non-detection are NA. then remove all the Na's.

```{r}
elevH<-read.csv("InputData/HummingbirdElevation.csv",row.names=1)
head(elevH)
colnames(elevH)[5]<-"Elevation"
elevH$Bird<-1:nrow(elevH)

#high elevation or low elevation
elevP<-read.csv("InputData/PlantElevation.csv",row.names=1)
colnames(elevP)[5]<-"Elevation"
elevP$Plant<-1:nrow(elevP)
elevP$Iplant_Double<-as.character(elevP$Iplant_Double)

#Correct known taxonomic errors
elevP[elevP$Iplant_Double %in% "Alloplectus purpureus","Iplant_Double"]<-"Glossoloma purpureum"
elevP[elevP$Iplant_Double %in% "Capanea affinis","Iplant_Double"]<-"Kohleria affinis"
elevP[elevP$Iplant_Double %in% "Alloplectus teuscheri","Iplant_Double"]<-"Drymonia teuscheri"
elevP[elevP$Iplant_Double %in% "Columnea cinerea","Iplant_Double"]<-"Columnea mastersonii"
elevP[elevP$Iplant_Double %in% "Alloplectus tenuis","Iplant_Double"]<-"Drymonia tenuis"

#Merge to observed Data
#plants
dathp<-merge(dath,elevP,by="Iplant_Double")

#birds
datph<-merge(dathp,elevH,by="Hummingbird")

```

### Summarize Observations

```{r}
#ID for NA is holger transects, make the id's 1:n for each day of transect at each elevation, assuming no elevation was split across days.
datph$ID<-as.character(datph$ID)

noid<-datph[is.na(datph$ID),]

id_topaste<-paste(noid$Transect_R,noid$DateP,"Transect",sep="_")
datph[which(is.na(datph$ID)),"ID"]<-id_topaste

#Create year month combination
datph$Time<-paste(datph$Month,datph$Year,sep="_")

#Label survey type
datph$Survey_Type<-NA

mt<-!is.na(datph$TransectID)*1
datph$Survey_Type[mt==1]<-"Transect"
datph$Survey_Type[!datph$Survey_Type %in% "Transect"]<-"Camera"

indatraw<- datph %>% group_by(Hummingbird,Iplant_Double,Bird,Plant,Time,ID,DateP,Survey_Type) %>% summarize(Yobs=n(),Elev=mean(ele,na.rm=T),Transect_R=unique(Transect_R)) 

#add day ID
sdat<-split(indatraw,list(indatraw$ID),drop = T)

sdat<-lapply(sdat,function(x){
  x<-droplevels(x)
  x$Day<-as.numeric(as.factor(x$DateP))
  return(x)
})

indatraw<-rbind_all(sdat)

#Species names
for (x in 1:nrow(indatraw)){
  indatraw$Hummingbird[x]<-as.character(elevH[elevH$Bird %in% indatraw$Bird[x],"Hummingbird"])
  indatraw$Iplant_Double[x]<-as.character(elevP[elevP$Plant %in% indatraw$Plant[x],"Iplant_Double"])
}
```

What elevation transect is each observation in?
The camera data need to be inferred from the GPS point.

```{r}
#cut working best on data.frame
indatraw<-as.data.frame(indatraw)

#which elevation bin is each observation within
labs<-paste(seq(1300,2500,200),seq(1500,2700,200),sep="_")
indatraw$Transect_R[is.na(indatraw$Transect_R)]<-as.character(cut(indatraw[is.na(indatraw$Transect_R),]$Elev,seq(1300,2700,200),labels=labs))

#Elev for the transects is the midpoint
tran_elev<-indatraw[indatraw$Survey_Type=='Transect',"Transect_R"]
indatraw[indatraw$Survey_Type=='Transect',"Elev"]<-sapply(tran_elev,function(x){
  mean(as.numeric(str_split(x,"_")[[1]]))
})
```

```{r}
#match the traits
traitmelt<-melt(traitmatchT)
colnames(traitmelt)<-c("Hummingbird","Iplant_Double","Traitmatch")
```

##Absences - accounting for non-detection

We have more information than just the presences, given species elevation ranges, we have absences as well. Absences are birds that occur at the elevation of the plant sample, but were not recorded feeding on the flower.

```{r}
indatlong<-acast(indatraw,Bird~Plant~Time~ID~Day,value.var="Yobs")

indatlong[is.na(indatlong)]<-0
```

```{r}
#Only non-detections are real 0's, the rest are NA's and are removed.
#Plants not surveyed in that time period
#Hummingbirds not present at that elevation

for(t in 1:dim(indatlong)[3]){
  for(x in 1:dim(indatlong)[4]){
  
  #Remove non sampled plants 
  a<-indatlong[,,t,x,]

  #No observations at that plant
  toNA<-as.numeric(names(which(apply(a,2,sum)==0)))
  pres<-as.numeric(names(which(!apply(a,2,sum)==0)))
  indatlong[,colnames(a) %in% toNA,t,x,]<-NA

  if(length(pres)==0){next} else {
    #IDs are unique to time periods.

    indatlong[,,which(!dimnames(indatlong)[[3]] %in% dimnames(indatlong)[[3]][t]),x,]<-NA
    
  #Get elevation point of that sampling event
  cam<-dimnames(indatlong)[[4]][x]
  camelev<-indatraw %>% filter(ID==cam) %>% .$Elev %>% unique()
      
  #for each hummingbird, was that camera within elevation?
  for(i in 1:dim(a)[1]){
      low<-elevH[elevH$Bird == rownames(a)[i],"Low"]
      high<-elevH[elevH$Bird == rownames(a)[i],"High"]
        
        #if not in elev range, set to NA
        
        if(!((low < camelev) & (camelev < high))){
            if(sum(indatlong[i,,t,x,],na.rm=T)>0){next}
          #if you had a wandering individual outside range, allow interaction to occur.
                indatlong[i,,t,x,]<-NA
        }
      }
    }
  }
}
### There can't be absences in days that weren't sampled.
for (x in 1:dim(indatlong)[4]){
  cam<-indatlong[,,,x,]
  for (y in 1:dim(cam)[4]){
    sc<-sum(cam[,,,y],na.rm=T)
    if (sc ==0){
      indatlong[,,,x,y]<-NA
    }
  }
}

#melt and remove Na's
indat<-melt(indatlong)
indat<-indat[!is.na(indat$value),]

colnames(indat)<-c("Bird","Plant","Time","ID","Day","Yobs")
```

```{r}
#remerge the time period data
Timelookup<-indatraw %>% dplyr::select(ID,Transect_R,Survey_Type) %>% group_by(ID,Transect_R,Survey_Type) %>% distinct() %>% arrange(ID)

#Get time information
indat<-merge(indat,Timelookup,by=c("ID"))

#Species names
for (x in 1:nrow(indat)){
  indat$Hummingbird[x]<-as.character(elevH[elevH$Bird %in% indat$Bird[x],"Hummingbird"])
  indat$Iplant_Double[x]<-as.character(elevP[elevP$Plant %in% indat$Plant[x],"Iplant_Double"])
}

#Get trait information
#match the traits
indat<-merge(indat,traitmelt,by=c("Hummingbird","Iplant_Double"))
```

Reformat index for jags.
Jags needs a vector of input species 1:n with no breaks.

```{r}
#Easiest to work with jags as numeric ordinal values
indat$Hummingbird<-as.factor(indat$Hummingbird)
indat$Iplant_Double<-as.factor(indat$Iplant_Double)
indat$jBird<-as.numeric(indat$Hummingbird)
indat$jPlant<-as.numeric(indat$Iplant_Double)

jagsIndexBird<-data.frame(Hummingbird=levels(indat$Hummingbird),jBird=1:length(levels(indat$Hummingbird)))
 
jagsIndexPlants<-data.frame(Iplant_Double=levels(indat$Iplant_Double),jPlant=1:length(levels(indat$Iplant_Double)))

#Similiarly, the trait matrix needs to reflect this indexing.
jTraitmatch<-traitmatchT[rownames(traitmatchT) %in% unique(indat$Hummingbird),colnames(traitmatchT) %in% unique(indat$Iplant_Double)]
```

#Resources at each month

In our model the covariate is indexed at the scale at which the latent count is considered fixed. This means we need the resource availability per month across the entire elevation gradient for each point.

```{r}
fl<-read.csv(paste(droppath,"Thesis/Maquipucuna_SantaLucia/Results/FlowerTransects/FlowerTransectClean.csv",sep=""))

#select desired columns
fltransects<-fl %>% dplyr::select(Iplant_Double,month,Year,ID,Transect.ID,Family,Genus,Species,Height,Total_Flowers,Transect_R,Date,lon,lat,ele)

#dates need a bit of formatting
fltransects$DateP<-as.POSIXlt(fltransects$Date,format="%d/%m/%y")

#which are NA needs to date/month reversed. ugly.
fltransects[which(is.na(fltransects$DateP)),"DateP"]<-as.character(as.POSIXlt(as.character(fltransects[which(is.na(fltransects$DateP)),"Date"]),format="%m/%d/%Y"))

#remove without elevation records (less than 1% of data)
fltransects<-fltransects[!is.na(fltransects$ele),]

#month should be capital 
colnames(fltransects)[colnames(fltransects) %in% "month"]<-"Month"

#Count of flowers per month
fltransects$DateP<-as.character(fltransects$DateP)
flower.month<-group_by(fltransects,Month,Year,Transect_R,DateP) %>% dplyr::summarise(Flowers=sum(Total_Flowers,na.rm=TRUE))  %>% filter(Flowers>20)
  
#Make month abbreviation column, with the right order
flower.month$Month.a<-factor(month.abb[flower.month$Month],month.abb[c(1:12)])

#Make year factor column
flower.month$Year<-as.factor(flower.month$Year)

#get quantile for each transect
thresh<-melt(group_by(flower.month) %>% summarize(Threshold=mean(log(Flowers))))
             
flower.month<-merge(flower.month,thresh)
flower.month$Availability<-as.factor((log(flower.month$Flowers)>flower.month$value) * 1)

#plot
ggplot(flower.month,aes(col=Availability,x=Month.a,log(Flowers),shape=as.factor(Year))) + geom_point(size=3) + theme_bw()  + geom_smooth(aes(group=1)) + ylab("Flowers") + xlab("Month") + facet_wrap(~Transect_R,scales="free_y") + labs(shape="Year", y= "Log Available Flowers") + scale_x_discrete(breaks=month.abb[seq(1,12,2)]) + scale_color_manual(labels=c("Low","High"),values=c("black","red")) 

#turn min and max elvation into seperate columns for the range
flower.month$minElev<-as.numeric(str_extract(flower.month$Transect_R,"(\\d+)"))
flower.month$maxElev<-as.numeric(str_match(flower.month$Transect_R,"(\\d+)_(\\d+)")[,3])
```

```{r}
#summarize per month
#Count of flowers per month
Fmonth<-flower.month %>%group_by(Month,Year,Transect_R) %>% summarise(Flowers=mean(Flowers)) %>% summarize(Flowers=mean(Flowers)) %>% mutate(Time=paste(Month,Year,sep="_")) 

#Binary model
Fmonth$Availability<-(log(Fmonth$Flowers) > mean(log(Fmonth$Flowers)) )*1 
ggplot(Fmonth,aes(x=as.factor(Month),y=log(Flowers))) + geom_point(size=4,aes(col=as.factor(Availability))) + geom_line(aes(group=Year)) + labs(x="Month",y="Log Transformed Flower Count")
indat<-merge(indat,Fmonth,by="Time")

#As matrix
indat<-dcast(indat,...~Survey_Type,value.var="Yobs",fill=NA)

#Turn Time and ID into numeric indexes
indat$jTime<-as.numeric(as.factor(indat$Time))
indat$jID<-as.numeric(as.factor(indat$ID))

#index resources
resourceMatrix<-indat %>% group_by(jBird,Time) %>% summarize(v=unique(Flowers)) %>% mutate(v=scale(v)) %>% acast(jBird ~ Time,value.var='v',fill=0)
```

#Exporatory Analysis

```{r}
ggplot(indat,aes(x=Traitmatch)) + geom_point(aes(y=Camera),col='blue') + geom_point(aes(y=Transect),col='red') + stat_smooth(method="glm",family="poisson",aes(y=Transect),col='red') + stat_smooth(method="glm",family="poisson",aes(y=Camera),col='blue')
```

Sampling effort

```{r}
#At each data point there is a camera a transect or both
cam_effort<-(!is.na(indat$Camera))*1
trans_effort<-(!is.na(indat$Transect))*1
```

#Hierarchical Occupancy Model

For hummingbird species i feeding on plant species j observed at time k and sampling event d. 

$$ YTransect_{i,j,k,d} \sim B(N_{i,j,k},\omega_{Transect}) $$

$$ YCamera_{i,j,k,d} \sim B(N_{i,j,k},\omega_{Camera}) $$
$$ \omega_{Camera} <- \phi_{Camera} * EffortCamera_k $$
$$ \omega_{Transect} <- \phi_{Transect}* EffortTransect_k $$
$$ N_{i,j,k} \sim Pois(\lambda_{i,j,k}) $$
$$ log(\lambda_{i,j,k}) = \alpha_i + \beta_{1,i} * Traitmatch_{i,j} + \beta_{2,i} *Resources_k + \beta_{3,i} * Traitmatch_{i,j} * Resources_k $$

**Priors**

$$ \phi_{Camera} \sim U(0,1) $$
$$ \phi_{Transect} \sim U(0,1) $$
$$\alpha_i \sim N(intercept,\tau_{\alpha})$$
$$\beta_{1,i} \sim N(\gamma_1i,\tau_{\beta_1})$$
$$\beta_{2,i} \sim N(\gamma_2i,\tau_{\beta_2})$$
$$\beta_{3,i} \sim N(\gamma_3i,\tau_{\beta_3})$$

**Hyperpriors**

Group Level Means

$$\gamma_{1,i} \sim N(0,0.0001)$$
$$\gamma_{2,i} \sim N(0,0.0001)$$
$$\gamma_{3,i} \sim N(0,0.0001)$$
$$ intercept \sim N(0,0.0001)$$

Group Level Variance

$$\tau_{\alpha} \sim Gamma(0.0001,0.0001)$$
$$\tau_\beta1 \sim Gamma(0.0001,0.0001)$$
$$\tau_\beta2 \sim Gamma(0.0001,0.0001)$$
$$\tau_\beta3 \sim Gamma(0.0001,0.0001)$$

**Derived quantities**

$$\sigma_{intercept} = \sqrt[2]{\frac{1}{\tau_\alpha}}$$
$$\sigma_{slope1} = \sqrt[2]{\frac{1}{\tau_{\beta_1}}}$$
$$\sigma_{slope2} = \sqrt[2]{\frac{1}{\tau_{\beta_2}}}$$
$$\sigma_{slope3} = \sqrt[2]{\frac{1}{\tau_{\beta_3}}}$$

```{r,eval=T,strip.white=T}

#Source model
source("Bayesian/NmixturePoissonRagged2m_trait.R")

#print model
writeLines(readLines("Bayesian/NmixturePoissonRagged2m_trait.R"))

#Input Data
Dat <- c('Yobs_camera','Yobs_transect','Birds','Bird','Plant','Time','Plants','Times','resources','Nobs','cam_surveys','trans_surveys','Traitmatch')

#Inits
InitStage <- function(){
  #A blank Y matrix - all present
  initY<-array(dim=c(Birds,Plants,Times),30)
  initB<-as.numeric(matrix(nrow=Birds,ncol=1,data=0))
  initD<-as.numeric(matrix(nrow=Birds,ncol=1,data=.5))

#list(beta1=initB,beta2=initB,beta3=initB,alpha=rep(.5,Birds),intercept=0,tau_alpha=0.1,tau_beta1=0.1,tau_beta2=0.1,tau_beta3=0.1,gamma1=0,gamma2=0,gamma3=0,dtrans=0.5,dcam=0.5,N=initY)}

list(beta1=initB,alpha=rep(.5,Birds),intercept=1,tau_alpha=0.1,tau_beta1=0.1,gamma1=0,dtrans=0.3,dcam=0.2,N=initY)}

#Parameters to track
ParsStage <- c("alpha","beta1","intercept","sigma_int","sigma_slope1","gamma1","dtrans","dcam")

#ParsStage <- c("alpha","beta1","beta2","beta3","intercept","sigma_int","sigma_slope1","sigma_slope2","sigma_slope3","gamma1","gamma2","gamma3","dtrans","dcam")

#MCMC options
ni <- 50000  # number of draws from the posterior
nt <- max(c(1,ni*.0001))  #thinning rate
nb <- ni*.85 # number to discard for burn-in
nc <- 2  # number of chains

#Jags

  Yobs_camera = indat$Camera
  Yobs_transect = indat$Transect

  Birds=max(indat$jBird)
  Bird=indat$jBird
  Plant=indat$jPlant
  Time=indat$jTime
  Plants=max(indat$jPlant)
  Times=max(indat$jTime)
  resources=resourceMatrix
  Nobs=nrow(indat)
  cam_surveys= cam_effort
  trans_surveys= trans_effort
  Traitmatch=jTraitmatch

  m2<-do.call(jags.parallel,list(Dat,InitStage,ParsStage,model.file="Bayesian/NmixturePoissonRagged2m_trait.jags",n.thin=nt, n.iter=ni,n.burnin=nb,n.chains=nc))
```

```{r,eval=F}
#recompile if needed
load.module("dic")
runs<-40000
recompile(m2)
m2<-update(m2,n.iter=runs,n.burnin=runs*.9,n.thin=3)
```

```{r}
#extract par to data.frame
pars_detect<-extract_par(m2,data=indat,Bird="jBird",Plant="jPlant")
```

##Assess Convergence

```{r,cache=FALSE,fig.width=13,fig.height=5}
###Chains
ggplot(pars_detect[pars_detect$par %in% c("alpha","beta1"," beta2","beta3"),],aes(x=Draw,y=estimate,col=as.factor(Chain))) + geom_line() + facet_grid(par~species,scale="free") + theme_bw() + labs(col="Chain") + ggtitle("Species Level")

ggplot(pars_detect[pars_detect$par %in% c("dcam","dtrans"),],aes(x=Draw,y=estimate,col=as.factor(Chain))) + geom_line() + facet_grid(par~species,scale="free") + theme_bw() + labs(col="Chain") + ggtitle("Species Level")
```

```{r,fig.height=5,fig.width=11}
ggplot(pars_detect[pars_detect$par %in% c("gamma1","intercept","sigma_int","sigma_slope1","gamma2","gamma3","sigma_slope2","sigma_slope3"),],aes(x=Draw,y=estimate,col=as.factor(Chain))) + geom_line() + theme_bw() + labs(col="Chain") + ggtitle("Group Level Parameters") + facet_wrap(~par,scales="free")
```

#Posteriors

```{r,cache=FALSE,fig.width=11,fig.height=14}
###Posterior Distributions
ggplot(pars_detect[pars_detect$par %in% c("alpha","beta1","beta2","beta3"),],aes(x=estimate)) + geom_histogram(position='identity') + ggtitle("Estimate of parameters") + facet_grid(species~par,scales="free") + theme_bw() + ggtitle("Species Parameters")
```

```{r,cache=FALSE,fig.width=10,fig.height=5}
#Detection figure
ggplot(pars_detect[pars_detect$par %in% c("dtrans","dcam"),],aes(x=par,y=estimate)) + geom_violin(fill='black') + ggtitle("Estimate of parameters") + theme_bw() + ggtitle("Detection Probability") + facet_wrap(~species)

pars_detect<-merge(pars_detect,jagsIndexBird,by.x="species",by.y="jBird",all.x=T)

ggplot(pars_detect[pars_detect$par %in% c("dcam","dtrans"),],aes(x=estimate)) + geom_histogram() + ggtitle("Posterior Distribution") + theme_bw() + facet_wrap(~species,ncol=5) + xlab("Probability of Detection")
#ggsave("Figures/DetectionProb.jpg",dpi=300,height=7,width=11)
```

```{r,cache=FALSE,fig.height=5,fig.width=13}
ggplot(pars_detect[pars_detect$par %in% c("gamma1","gamma2","gamma3","intercept","sigma_int","sigma_slope1","sigma_slope2","sigma_slope3"),],aes(x=estimate)) + geom_histogram() + ggtitle("Group Level Posteriors") + facet_wrap(~par,scale="free",nrow=2) + theme_bw() 
```

#Predicted Relationship 

```{r,fig.height=4,fig.width=4}
#Expand out pars
castdf<-dcast(pars_detect[pars_detect$par %in% c("gamma1","gamma2","gamma3","intercept"),], Chain + Draw~par,value.var="estimate")
```

Hold resource relationship at 0, what does trait-matching look like?

```{r,fig.width=9,fig.height=7}
#Trajectories from posterior
predy<-trajF(alpha=castdf$intercept,beta1=castdf$gamma1,x=indat$Traitmatch,resources=indat$Flowers,beta2=0,beta3=0,type='hdi')

ggplot(data=predy,aes(x=x)) + geom_ribbon(aes(ymin=lower,ymax=upper),alpha=0.1,fill="red")  + geom_line(aes(y=mean),size=.5,col="red",linetype="dashed") + theme_bw() + ylab("Interactions") + xlab("Difference between Bill and Corolla Length") + geom_point(data=indat,aes(x=Traitmatch,y=Camera)) + geom_point(data=indat,aes(x=Traitmatch,y=Transect))
```

##Full posterior prediction

```{r,fig.width=7,fig.height=6}
#Trajectories from posterior
predy<-trajF(alpha=castdf$intercept,beta1=castdf$gamma1,x=indat$Traitmatch,resources=scale(indat$Flowers),beta2=castdf$gamma3,beta3=castdf$gamma3,type='hdi')

ggplot(data=predy,aes(x=x)) + geom_ribbon(aes(ymin=lower,ymax=upper),alpha=0.2,fill="red")  +  theme_bw() + ylab("Interactions") + xlab("Difference between Bill and Corolla Length") + geom_point(data=indat,aes(x=Traitmatch,y=Camera)) + geom_line(aes(y=mean)) + geom_point(data=indat,aes(x=Traitmatch,y=Transect)) 
```


```{r}
gc()
save.image("Observed.Rdata")
```


