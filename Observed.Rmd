---
title: Niche overlap increases with increasing resource availability in a tropical
  plant-pollinator network.
author: "Ben Weinstein"
date: "Tuesday, October 14, 2014"
output:
  html_document:
    theme: spacelab
  word_document: default
  keep_md: true
---

#Aim
Which birds use which plants? What are the mechanisms that determine niche overlap in this assemblage

##Data

* Using automated cameras and transects, we have been recording flower visitation rates by each hummingbird species for two years.
* We have bill and corolla lengths for each species of bird and flower.
* We have been collecting phenology data on available resources

Birds use flowers that have similar length of bill shape and we expect the importance of trait matching to decrease as available resources increase.

```{r,echo=FALSE,warning=FALSE,message=FALSE}
library(knitr)
library(R2jags)
library(reshape2)
library(ggplot2)
library(scales)
library(dplyr)
library(stringr)
library(picante)
library(igraph)
library(bipartite)
library(chron)
library(gridExtra)
library(MASS)

#Set Dropbox Location
#setwd to dropbox
droppath<-"C:/Users/Ben/Dropbox/"

#Set github path
gitpath<-"C:/Users/Ben/Documents/NetworkTime/"

setwd(gitpath)

opts_chunk$set(message=FALSE,warning=FALSE,fig.height=9,fig.width=13,echo=FALSE,cache=F, fig.path='figure/')

#source bayes functions
source("Bayesian/BayesFunctions.R")
```

```{r,eval=F}
#load data is needed
#load("Observed.RData")
```

#Read in Data
```{r}
###Read in data
#read in flower morphology data, comes from Nectar.R
droppath<-"C:/Users/Ben/Dropbox/"
fl.morph<-read.csv(paste(droppath,"Thesis/Maquipucuna_SantaLucia/Results/FlowerMorphology.csv",sep=""))

#First row is empty
fl.morph<-fl.morph[-1,]

#Bring in Hummingbird Morphology Dataset, comes from
hum.morph<-read.csv(paste(droppath,"Thesis/Maquipucuna_SantaLucia/Results/HummingbirdMorphology.csv",sep=""))

#Bring in Interaction Matrix
int<-read.csv(paste(droppath,"Thesis/Maquipucuna_SantaLucia/Results/Network/HummingbirdInteractions.csv",sep=""),row.names=1)

m.dat<-int[colnames(int) %in% c("ID","Video","Time","Hummingbird","Sex","TransectID","Transect_R","Iplant_Double","Pierce","DateP","Month","ele","Type")]

m.dat$Year<-years(as.Date(m.dat$DateP))
#one missing date
m.dat$Year[m.dat$Year %in% 2012]<-2013

#Fix spacing to match clades

#Which are matching
levels(m.dat$Hummingbird)[!levels(m.dat$Hummingbird) %in% hum.morph$English]

#This needs to be checked
#print(paste(levels(m.dat$Hummingbird)[!levels(m.dat$Hummingbird) %in% hum.morph$English],"not matched"))

#Number of bird species
h_species<-nlevels(m.dat$Hummingbird)

#Number of plant species
plant_species<-nlevels(m.dat$Iplant_Double)

#Get english name
dath<-merge(m.dat,hum.morph, by.x="Hummingbird",by.y="English",keep=all)

#Merge to flowers
int.FLlevels<-levels(factor(dath$Iplant_Double))

#Which flowers are we missing info for?
missingTraits<-int.FLlevels[!int.FLlevels %in% fl.morph$X]

print(paste("Missing Trait Information:",missingTraits))
dath<-merge(dath,fl.morph, by.x="Iplant_Double",by.y="X")

#Drop piercing events, since they don't represent correlation
dath<-dath[!dath$Pierce %in% c("y","Y"),]
```

#Available Resources

```{r}
#read in flower totals from FlowerTransects.R
fltransects<-read.csv(paste(droppath,"Thesis/Maquipucuna_SantaLucia/Results/FlowerTransects/FlowerTransectClean.csv",sep=""))

#dates need a bit of formatting
fltransects$DateP<-as.POSIXlt(fltransects$Date,format="%d/%m/%y")

#which are NA needs to date/month reversed. ugly.
fltransects[which(is.na(fltransects$DateP)),"DateP"]<-as.character(as.POSIXlt(as.character(fltransects[which(is.na(fltransects$DateP)),"Date"]),format="%m/%d/%Y"))

#remove withour elevation records (less than 1% of data)
fltransects<-fltransects[!is.na(fltransects$ele),]

#month should be capital 
colnames(fltransects)[colnames(fltransects) %in% "month"]<-"Month"

#Count of flowers per month
fltransects$DateP<-as.character(fltransects$DateP)
flower.month<-group_by(fltransects,Month,Year,Transect_R,Date_F) %>% dplyr::summarise(Flowers=sum(Total_Flowers,na.rm=TRUE))  %>% filter(Flowers>20)
  
#Make month abbreviation column, with the right order
flower.month$Month.a<-factor(month.abb[flower.month$Month],month.abb[c(1:12)])

#Make year factor column
flower.month$Year<-as.factor(flower.month$Year)

#get quantile for each transect
thresh<-melt(group_by(flower.month,Transect_R) %>% summarize(Threshold=quantile(log(Flowers),0.8)) )
flower.month<-merge(flower.month,thresh)
flower.month$Availability<-as.factor((log(flower.month$Flowers)>flower.month$value) * 1)
#plot
ggplot(flower.month,aes(x=Month.a,log(Flowers),shape=as.factor(Year),col=Availability)) + geom_point(size=3) + theme_bw()  + geom_smooth(aes(group=1)) + ylab("Flowers") + xlab("Month") + facet_wrap(~Transect_R,scales="free_y") + labs(shape="Year", y= "Log Available Flowers") + scale_x_discrete(breaks=month.abb[seq(1,12,2)]) + scale_color_manual(labels=c("Low","High"),values=c("black","red")) + labs(col="Resource Availability")

#turn min and max eelvation into seperate columns for the range
flower.month$minElev<-as.numeric(str_extract(flower.month$Transect_R,"(\\d+)"))
flower.month$maxElev<-as.numeric(str_match(flower.month$Transect_R,"(\\d+)_(\\d+)")[,3])

```

### What is the temporal distribution of resources?
```{r}
#moment 
moment<-fitdistr(flower.month$Flowers,"log-normal")

est<-data.frame(x=seq(0,max(flower.month$Flowers),100),Flowers=dlnorm(x=seq(0,max(flower.month$Flowers),100),meanlog=moment$estimate[1],sdlog=moment$estimate[2]))
ggplot(flower.month,aes(x=Flowers)) + geom_density(fill="black") + geom_line(data=est,aes(x=x,y=Flowers),col='red') + theme_bw() + labs(x="Total Monthly Available Resources",y="Density") + ggtitle("Resources are exponentially distributed over time")
```

Appears to be a log normal distribution with the existance of rare, but intense, pulses.

##Match Species to Morphology

```{r}
#remove species with less than  10 observations
keep<-names(which(table(dath$Hummingbird) > 10))

dath<-droplevels(dath[dath$Hummingbird %in% keep,])

#observed traitmatching
traitmatchF<-abs(t(sapply(hum.morph$Bill,function(x){x-fl.morph$TotalCorolla})))

rownames(traitmatchF)<-hum.morph$English
colnames(traitmatchF)<-fl.morph$Group.1
```

```{r}
#match names
#Round to 2 decimals
#Convert to cm for winbugs, avoids numerical underflow
traitmatchT<-round(traitmatchF[rownames(traitmatchF) %in% dath$Hummingbird,colnames(traitmatchF) %in% dath$Iplant_Double],2)/10
```

```{r}
#Formatting indexes
dath$Bird<-as.numeric(factor(dath$Hummingbird,sort(unique(dath$Hummingbird))))
dath$Plant<-as.numeric(factor(dath$Iplant_Double,sort(unique(dath$Iplant_Double))))
dath$obs<-1

traitmatchT<-traitmatchT[sort(rownames(traitmatchT)),sort(colnames(traitmatchT))]

#Create an index to connect to species names
#remerge species levels
bindex<-data.frame(Index=1:length(rownames(traitmatchT)),Species=rownames(traitmatchT))

pindex<-data.frame(Index=1:length(colnames(traitmatchT)),Species=colnames(traitmatchT))
```

###Elevation ranges

Create a binary variable whether each observation was in a low elevation or high elevation transect. We have some species that just occur at the top of the gradient, and are not present in the sampling window of flowers at the low elevation.

Accounting for non-availability.
We have to figure out which plants were sampled in which periods, and if it was sampled, the non-detection are 0 if it wasn't the non-detection are NA. then remove all the Na's.

```{r}
elevH<-read.csv("InputData/HummingbirdElevation.csv",row.names=1)
head(elevH)
colnames(elevH)[5]<-"Elevation"

#merge to names
elevH<-merge(bindex,elevH,by.x="Species",by.y="Hummingbird")

#remove plant species without dual names
keepp<-colnames(traitmatchT)[which(!sapply(strsplit(colnames(traitmatchT), " "), length)==1)]

#must have atleast 10 observations
keepp<-keepp[keepp %in% names(which(table(dath$Iplant_Double) >  5))]
  
#high elevation or low elevation
elevP<-read.csv("InputData/PlantElevation.csv",row.names=1)
elevP<-elevP[elevP$Iplant_Double %in% keepp,]
colnames(elevP)[5]<-"Elevation"

elevP<-merge(pindex,elevP,by.x="Species",by.y="Iplant_Double",keep=all)
```

```{r}
#ID for NA is 1
dath$ID<-as.character(dath$ID)
dath[which(is.na(dath$ID)),"ID"]<-dath$TransectID[which(is.na(dath$ID))]

indatraw<- dath %>% group_by(Bird,Plant,ID,DateP) %>% summarize(Yobs=n(),Elev=mean(ele,na.rm=T)) %>% filter(Plant %in% elevP$Index) %>% ungroup() %>% arrange(desc(Yobs)) %>% mutate(Time=as.numeric(as.factor(as.character(paste(ID,DateP))))) 

#add months and years
indatraw$Month<-as.numeric(factor(months(strptime(indatraw$DateP,format="%Y-%m-%d")),levels=month.name))
indatraw$Year<-years(indatraw$DateP)
```

What elevation transect is each observation in?

```{r}
#which elevation bin is each observation within
labs<-paste(seq(1300,2500,200),seq(1500,2700,200),sep="_")
indatraw$Transect_R<-cut(indatraw$Elev,seq(1300,2700,200),labels=labs)
```

```{r}
indatlong<-acast(indatraw,Bird~Plant~Time~Transect_R,value.var="Yobs")

indatlong[is.na(indatlong)]<-0
```

Before we account for elevation and availability, what is the distribution of intensity of interactions?

```{r}
ggplot(indatraw,aes(x=Yobs)) + geom_histogram()
```

If we tend to think of the intensity of events as poisson, our data is extremely ones-inflated. The first moment of the poisson does not well capture the data.

The best fitting moment is in opaque red. The observed data is in black.

```{r}
moment<-fitdistr(indatraw$Yobs,"poisson")
est<-data.frame(Yobs=rpois(n=length(indatraw$Yobs),lambda=moment$estimate[[1]]))
ggplot(indatraw,aes(x=Yobs)) + geom_histogram(fill="black") + geom_histogram(data=est,fill="red",alpha=.4) + theme_bw() + ggtitle("Intensity of interactions")
```

What about negative binomial?

The best fitting moment is in opaque red. The observed data is in black.

```{r}
moment<-fitdistr(indatraw$Yobs,"negative binomial")
est<-data.frame(Yobs=rpois(n=length(indatraw$Yobs),lambda=moment$estimate[[1]]))
ggplot(indatraw,aes(x=Yobs)) + geom_histogram(fill="black") + geom_histogram(data=est,fill="red",alpha=.4) + theme_bw()
```

What about log normal?

```{r}
moment<-fitdistr(indatraw$Yobs,"lognormal")
est<-data.frame(Yobs=rpois(n=length(indatraw$Yobs),lambda=moment$estimate[[1]]))
ggplot(indatraw,aes(x=Yobs)) + geom_histogram(fill="black") + geom_histogram(data=est,fill="red",alpha=.4) + theme_bw()
```

The best fitting moment is in opaque red. The observed data is in black.

Ignoring non-detections for the moment.

##Resource availability at each data point

```{r}
#merge with original data, easier to do as factors
indatraw<-as.tbl(indatraw)
indatraw$Time<-as.factor(indatraw$Time)

#flower surveys are done twice a month, get the average
flower.monthD<-flower.month %>% arrange(Month,Year,Transect_R) %>% group_by(Month,Year,Transect_R) %>% summarize(Flowers=mean(Flowers,na.rm=T),Availability=max(as.numeric(as.character(Availability))))

#We lose some data here, needs to be cleaned.
obs<-merge(indatraw,flower.monthD,by=c("Month","Year","Transect_R"))
```


```{r}
#match the traits
for(x in 1:nrow(obs)){
  obs$Traitmatch[x]<-traitmatchT[obs$Bird[x],obs$Plant[x]]
}

#add in hummingbird names
obs<-merge(obs,bindex,by.x="Bird",by.y="Index")
```

#Exploratory Model Fitting

First thought on sampling, take the mean interaction for each bird, plant combination for high and low resource periods. Connect intensity with a line.

```{r}
mobs<-obs[,] %>% group_by(Species,Plant,Availability) %>% summarize(Events=n(),d=mean(Yobs),Traitmatch=unique(Traitmatch))

#merge with names
mobss<-merge(mobs,pindex,by.x="Plant",by.y="Index")
colnames(mobss)<-c("Plant","Species","Availability","Events","d","Traitmatch","Iplant_Double")

ggplot(mobss,aes(x=Traitmatch,y=d,col=as.factor(Availability))) + geom_point(aes(size=Events),alpha=.8) + theme_bw() + facet_wrap(~Species,scales="free") + geom_line(aes(group=Plant),col="black") + scale_size_continuous(range=c(3,7)) + labs(col="Flower Availability")
```

##GLM

No accounting for detection. Also values independent.

```{r}
ggplot(obs[obs$Yobs>0,],aes(y=Yobs,x=Traitmatch)) + geom_jitter() +  stat_smooth(method="glm",family="poisson")

mod1<-glm(data=obs,family="poisson",Yobs ~ Traitmatch )
summary(mod1)
```

Mean position overtime

```{r}
mean_obs<-group_by(obs,Bird,Plant,Traitmatch) %>% summarize(n=mean(Yobs))
ggplot(mean_obs[,],aes(x=Traitmatch,y=n)) + geom_point() + stat_smooth(method="glm",family="poisson")
```

##Hierarchical Bayesian Model

```{r,eval=T,strip.white=T}

#Source model
source("Bayesian/PoissonRagged.R")

#print model
writeLines(readLines("Bayesian/PoissonRagged.R"))

#Input Data
Dat <- list(
  Yobs=obs$Yobs,
  Nobs=nrow(obs),
  
  #Index of Birds
  Bird=obs$Bird,
  
  #Index of Plants
  Plant=obs$Plant,
  
  #Index of time
  Time=obs$Time,
  
  #Length of birds
  Birds=max(obs$Bird),
  resources=obs$Availability,
  traitmatch=obs$Traitmatch)

#Inits
initB<-rep(.5,Dat$Birds)
InitStage <- function(){list(beta1=initB,beta2=initB,beta3=initB,alpha=initB,intercept=0,tau_alpha=0.1,tau_beta1=0.1,tau_beta2=0.1,tau_beta3=0.1,gamma1=0,gamma2=0,gamma3=0)}

#Parameters to track
ParsStage <- c("alpha","beta1","beta2","beta3","intercept","sigma_int","sigma_slope1","sigma_slope2","sigma_slope3","gamma1","gamma2","gamma3","Yobs")

#MCMC options

ni <- 5000  # number of draws from the posterior
nt <- 2  #thinning rate
nb <- ni*.9 # number to discard for burn-in
nc <- 2  # number of chains

#Jags

m = jags(inits=InitStage,
         n.chains=nc,
         model.file="Bayesian/PoissonRagged.jags",
         working.directory=getwd(),
         data=Dat,
         parameters.to.save=ParsStage,
         n.thin=nt,
         n.iter=ni,
         n.burnin=nb,
         DIC=T)
```

```{r}
pars<-extract_par(m)

#Since this was a ragged matrix, need to correct the observed data species and plant

pars$plant<-as.numeric(pars$plant)

toc<-which(pars$par %in% "Yobs")
for (x in 1:length(toc)){
  row<-pars[toc[x],]
  #species is the xth position of observed data, it is incorrectly stored 
  pars[toc[x],"species"]<-obs[row$species,"Bird"]
  pars[toc[x],"plant"]<-obs[row$species,"Plant"]
  pars[toc[x],"Time"]<-obs[row$species,"Time"]
}
```

###Assess Convergence

```{r,cache=FALSE,eval=TRUE,fig.width=11,fig.height=5}
#Intercept
ggplot(pars[pars$par %in% c("alpha"),],aes(x=Draw,y=estimate,col=as.factor(Chain))) + geom_line() + facet_wrap(~species,scale="free") + theme_bw() + labs(col="Chain") + ggtitle("Detection Probability")

###Slopes
ggplot(pars[pars$par %in% c("alpha","beta1","beta2","beta3"),],aes(x=Draw,y=estimate,col=as.factor(Chain))) + geom_line() + facet_grid(par~species,scale="free") + theme_bw() + labs(col="Chain") + ggtitle("Regression Convergence")

```

```{r,fig.height=5,fig.width=11,eval=T}
ggplot(pars[pars$par %in% c("gamma1","gamma2","gamma3","sigma_int","sigma_slope1","sigma_slope2","sigma_slope3"),],aes(x=Draw,y=estimate,col=as.factor(Chain))) + geom_line() + theme_bw() + labs(col="Chain") + ggtitle("Trait-matching Hierarchical regression") + facet_wrap(~par,scales="free")
```

###Posteriors

```{r,cache=FALSE,fig.width=7,fig.height=13}

#intercept
ggplot(pars[pars$par %in% c("alpha"),],aes(x=estimate,fill=as.factor(species))) + geom_histogram() + ggtitle("Estimate of parameters") + theme_bw() + ggtitle("Species Posteriors")

###Slope Posterior Distributions
psim<-ggplot(pars[pars$par %in% c("beta1","beta2","beta3"),],aes(x=estimate)) + geom_histogram() + ggtitle("Estimate of parameters") + facet_grid(species~par,scales="free") + theme_bw() + ggtitle("Species Posteriors")

#ggsave("Figures/ObservedPosteriors.jpg",dpi=300,height=8,width=8)
```

```{r,cache=FALSE,eval=TRUE,fig.height=13,fig.width=10}

psim2<-ggplot(pars[pars$par %in% c("gamma1","gamma2","gamma3","intercept","sigma_int","sigma_slope1","sigma_slope2","sigma_slope3"),],aes(x=estimate)) + geom_histogram() + ggtitle("Hierarchical Posteriors") + facet_wrap(~par,scale="free",nrow=2) + theme_bw() 

grid.arrange(psim,psim2,heights=c(.6,.4))
```

###Predicted Relationship 

```{r,fig.height=4,fig.width=4}
#get hierarchical parameters 

castdf<-dcast(pars[pars$par %in% c("gamma1","gamma2","gamma3","intercept"),], Chain + Draw~par,value.var="estimate")

```

Calculated predicted y

```{r}

predy<-trajF(alpha=castdf$intercept,beta1=castdf$gamma1,x=Dat$traitmatch,resources=Dat$resources,beta2=castdf$gamma2,beta3=castdf$gamma3)

psim3<-ggplot(data=predy,aes(x=x)) + geom_ribbon(aes(ymin=lower,ymax=upper),alpha=0.1,fill="red")  + geom_line(aes(y=mean),size=.8,col="red",linetype="dashed") + theme_bw() + ylab("Interactions") + xlab("Difference between Bill and Corolla Length") + geom_point(data=obs,aes(x=Traitmatch,y=Yobs))
psim3

#ggsave("Figures/SimulationResults.jpg",height=5,width=6,dpi=300)
```

###Visualize interactions

```{r}
predyint<-intF(alpha=castdf$intercept,beta1=castdf$gamma1,x=Dat$traitmatch,resources=Dat$resources,beta2=castdf$gamma2,beta3=castdf$gamma3)

psim4<-ggplot(data=predyint,aes(x=x)) + geom_ribbon(aes(ymin=lower,ymax=upper),alpha=0.3,fill="black") + theme_bw() + ylab("Effect of Resources on Trait Matching") + geom_line(aes(y=mean),size=.8,col="black",linetype="dashed") + xlab("Difference between Bill and Corolla Length") 

psim4
```

###Species Predictions

```{r}
#orignal data to plot as ppints
odat<-merge(obs,bindex,by.x="Bird",by.y="Index")
odat<-merge(odat,pindex,by.x="Plant",by.y="Index")
```

```{r,fig.height=10,fig.width=11,eval=T}

castdf<-dcast(pars[pars$par %in% c("beta1","beta2","beta3","alpha"),], species +Chain + plant+ Draw~par,value.var="estimate")

#Turn to 
castdf$species<-factor(castdf$species,levels=1:max(as.numeric(castdf$species)))

species.split<-split(castdf,list(castdf$species),drop = T)

species.traj<-list()

for(d in 1:length(species.split)){
  x<-species.split[[d]]
  index<-unique(x$species)
  
  #get data for those species
  billd<-obs[obs$Bird %in% index,]
  
  species.traj[[d]]<-trajF(alpha=x$alpha,beta1=x$beta1,beta2=x$beta2,beta3=x$beta3,resources=billd$Flowers,x=billd$Traitmatch)
  }

names(species.traj)<-names(species.split)

species.traj<-melt(species.traj,id.var=colnames(species.traj[[1]]))

#split out names and model
species.traj[,c("Index")]<-colsplit(species.traj$L1,"\\.",c("Index"))

spe<-merge(species.traj,bindex,by.x="Index",by.y="Index")

#match colnames
colnames(odat)[14:16]<-c("Species.x","Species","Iplant_Double")

#plot and compare to original data
p<-ggplot(data=spe,aes(x=x)) + geom_ribbon(aes(ymin=lower,ymax=upper),alpha=0.2) + geom_line(aes(y=mean),size=1) + theme_bw() + ylab("Interactions")+ xlab("Difference between Bill and Corolla Length") + facet_wrap(~Species,scales="free",ncol=3) + geom_point(data=odat,aes(x=Traitmatch,y=Yobs))

print(p)
```

###Posterior Check

```{r,fig.height=4,fig.width=8,eval=F}

fitstat<-droplevels(pars[pars$par %in% c("fit","fitnew"),])
fitstat<-dcast(fitstat,Draw+Chain~par,value.var="estimate")

#add 1:1 line

ymin<-round(min(c(fitstat$fit,fitstat$fitnew)))
ymax<-round(max(c(fitstat$fit,fitstat$fitnew)))
ab<-data.frame(x=ymin:ymax,y=ymin:ymax)
p<-ggplot(fitstat,aes(x=fit,y=fitnew)) + geom_point() + theme_bw() + coord_equal()
psim5<-p  + labs(x="Discrepancy of observed data",y="Discrepancy of replicated data",col="Model") + geom_line(data=ab,aes(x=x,y=y)) + ggtitle("Simulated Data")

psim5
```

```{r}
save.image("Observed.RData")
```
