---
title: Niche overlap increases with increasing resource availability in a tropical
  plant-pollinator network.
author: "Ben Weinstein"
date: "Tuesday, October 14, 2014"
output:
  html_document:
  toc: true
    theme: spacelab
  word_document: default
  keep_md: true
---

#Aim
Which birds use which plants? What are the mechanisms that determine niche overlap in this assemblage.

We will fit several difference types of models and ask how they inform our understanding. For each model, we try to calculate a measure of discrepancy and assess model fit.

##Data

* Using automated cameras and transects, we have been recording flower visitation rates by each hummingbird species for two years.
* We have bill and corolla lengths for each species of bird and flower.
* We have been collecting phenology data on available resources

Birds use flowers that have similar length of bill shape and we expect the importance of trait matching to decrease as available resources increase.

```{r,echo=FALSE,warning=FALSE,message=FALSE}
library(knitr)
library(R2jags)
library(reshape2)
library(ggplot2)
library(scales)
library(dplyr)
library(stringr)
library(lme4)
library(picante)
library(igraph)
library(bipartite)
library(effects)
library(chron)
library(gridExtra)
library(MASS)

#Set Dropbox Location
#setwd to dropbox
droppath<-"C:/Users/Ben/Dropbox/"

#Set github path
gitpath<-"C:/Users/Ben/Documents/NetworkTime/"

setwd(gitpath)

opts_chunk$set(message=FALSE,warning=FALSE,fig.height=9,fig.width=13,echo=FALSE,cache=F, fig.path='figure/')

#source bayes functions
source("Bayesian/BayesFunctions.R")
```

```{r,eval=F}
#load data is needed
load("Observed.RData")
```

#Read in Data
```{r}
#read in flower morphology data, comes from Nectar.R
droppath<-"C:/Users/Ben/Dropbox/"
fl.morph<-read.csv(paste(droppath,"Thesis/Maquipucuna_SantaLucia/Results/FlowerMorphology.csv",sep=""))

#First row is empty
fl.morph<-fl.morph[-1,]

#Bring in Hummingbird Morphology Dataset, comes from
hum.morph<-read.csv(paste(droppath,"Thesis/Maquipucuna_SantaLucia/Results/HummingbirdMorphology.csv",sep=""))

#Bring in Interaction Matrix
int<-read.csv(paste(droppath,"Thesis/Maquipucuna_SantaLucia/Results/Network/HummingbirdInteractions.csv",sep=""),row.names=1)

m.dat<-int[colnames(int) %in% c("ID","Video","Time","Hummingbird","Sex","TransectID","Transect_R","Iplant_Double","Pierce","DateP","Month","ele","Type")]

m.dat$Year<-years(as.Date(m.dat$DateP))
#one missing date
m.dat$Year[m.dat$Year %in% 2012]<-2013

#Fix spacing to match clades
#Which are matching
levels(m.dat$Hummingbird)[!levels(m.dat$Hummingbird) %in% hum.morph$English]

#This needs to be checked
#print(paste(levels(m.dat$Hummingbird)[!levels(m.dat$Hummingbird) %in% hum.morph$English],"not matched"))

#Number of bird species
h_species<-nlevels(m.dat$Hummingbird)

#Number of plant species
plant_species<-nlevels(m.dat$Iplant_Double)

#Get english name
dath<-merge(m.dat,hum.morph, by.x="Hummingbird",by.y="English",keep=all)

#Merge to flowers
int.FLlevels<-levels(factor(dath$Iplant_Double))

#Which flowers are we missing info for?
missingTraits<-int.FLlevels[!int.FLlevels %in% fl.morph$X]

print(paste("Missing Trait Information:",missingTraits))
dath<-merge(dath,fl.morph, by.x="Iplant_Double",by.y="X")

#Drop piercing events, since they don't represent correlation
dath<-dath[!dath$Pierce %in% c("y","Y"),]
```

#Available Resources

```{r}
#read in flower totals from FlowerTransects.R
fltransects<-read.csv(paste(droppath,"Thesis/Maquipucuna_SantaLucia/Results/FlowerTransects/FlowerTransectClean.csv",sep=""))

#dates need a bit of formatting
fltransects$DateP<-as.POSIXlt(fltransects$Date,format="%d/%m/%y")

#which are NA needs to date/month reversed. ugly.
fltransects[which(is.na(fltransects$DateP)),"DateP"]<-as.character(as.POSIXlt(as.character(fltransects[which(is.na(fltransects$DateP)),"Date"]),format="%m/%d/%Y"))

#remove withour elevation records (less than 1% of data)
fltransects<-fltransects[!is.na(fltransects$ele),]

#month should be capital 
colnames(fltransects)[colnames(fltransects) %in% "month"]<-"Month"

#Count of flowers per month
fltransects$DateP<-as.character(fltransects$DateP)
flower.month<-group_by(fltransects,Month,Year,Transect_R,Date_F) %>% dplyr::summarise(Flowers=sum(Total_Flowers,na.rm=TRUE))  %>% filter(Flowers>20)
  
#Make month abbreviation column, with the right order
flower.month$Month.a<-factor(month.abb[flower.month$Month],month.abb[c(1:12)])

#Make year factor column
flower.month$Year<-as.factor(flower.month$Year)

#get quantile for each transect
thresh<-melt(group_by(flower.month,Transect_R) %>% summarize(Threshold=quantile(log(Flowers),0.8)) )
flower.month<-merge(flower.month,thresh)
flower.month$Availability<-as.factor((log(flower.month$Flowers)>flower.month$value) * 1)
#plot
ggplot(flower.month,aes(x=Month.a,log(Flowers),shape=as.factor(Year),col=Availability)) + geom_point(size=3) + theme_bw()  + geom_smooth(aes(group=1)) + ylab("Flowers") + xlab("Month") + facet_wrap(~Transect_R,scales="free_y") + labs(shape="Year", y= "Log Available Flowers") + scale_x_discrete(breaks=month.abb[seq(1,12,2)]) + scale_color_manual(labels=c("Low","High"),values=c("black","red")) + labs(col="Resource Availability")

#turn min and max eelvation into seperate columns for the range
flower.month$minElev<-as.numeric(str_extract(flower.month$Transect_R,"(\\d+)"))
flower.month$maxElev<-as.numeric(str_match(flower.month$Transect_R,"(\\d+)_(\\d+)")[,3])

```

### What is the temporal distribution of resources?
```{r}
#moment 
moment<-fitdistr(flower.month$Flowers,"log-normal")

est<-data.frame(x=seq(0,max(flower.month$Flowers),100),Flowers=dlnorm(x=seq(0,max(flower.month$Flowers),100),meanlog=moment$estimate[1],sdlog=moment$estimate[2]))
ggplot(flower.month,aes(x=Flowers)) + geom_density(fill="black") + geom_line(data=est,aes(x=x,y=Flowers),col='red') + theme_bw() + labs(x="Total Monthly Available Resources",y="Density") + ggtitle("Resources are exponentially distributed over time")
```

Appears to be a log normal distribution with the existance of rare, but intense, pulses.

##Match Species to Morphology

```{r}
#remove species with less than  10 observations
keep<-names(which(table(dath$Hummingbird) > 10))

dath<-droplevels(dath[dath$Hummingbird %in% keep,])

#observed traitmatching
traitmatchF<-abs(t(sapply(hum.morph$Bill,function(x){x-fl.morph$TotalCorolla})))

rownames(traitmatchF)<-hum.morph$English
colnames(traitmatchF)<-fl.morph$Group.1
```

```{r}
#match names
#Round to 2 decimals
#Convert to cm for winbugs, avoids numerical underflow
traitmatchT<-round(traitmatchF[rownames(traitmatchF) %in% dath$Hummingbird,colnames(traitmatchF) %in% dath$Iplant_Double],2)/10
```

```{r}
#Formatting indexes
dath$Bird<-as.numeric(factor(dath$Hummingbird,sort(unique(dath$Hummingbird))))
dath$Plant<-as.numeric(factor(dath$Iplant_Double,sort(unique(dath$Iplant_Double))))
dath$obs<-1

traitmatchT<-traitmatchT[sort(rownames(traitmatchT)),sort(colnames(traitmatchT))]

#Create an index to connect to species names
#remerge species levels
bindex<-data.frame(Index=1:length(rownames(traitmatchT)),Species=rownames(traitmatchT))

pindex<-data.frame(Index=1:length(colnames(traitmatchT)),Species=colnames(traitmatchT))
```

###Elevation ranges

Create a binary variable whether each observation was in a low elevation or high elevation transect. We have some species that just occur at the top of the gradient, and are not present in the sampling window of flowers at the low elevation.

Accounting for non-availability.
We have to figure out which plants were sampled in which periods, and if it was sampled, the non-detection are 0 if it wasn't the non-detection are NA. then remove all the Na's.

```{r}
elevH<-read.csv("InputData/HummingbirdElevation.csv",row.names=1)
head(elevH)
colnames(elevH)[5]<-"Elevation"

#merge to names
elevH<-merge(bindex,elevH,by.x="Species",by.y="Hummingbird")

#remove plant species without dual names
keepp<-colnames(traitmatchT)[which(!sapply(strsplit(colnames(traitmatchT), " "), length)==1)]

#must have atleast 10 observations
keepp<-keepp[keepp %in% names(which(table(dath$Iplant_Double) >  5))]
  
#high elevation or low elevation
elevP<-read.csv("InputData/PlantElevation.csv",row.names=1)
elevP<-elevP[elevP$Iplant_Double %in% keepp,]
colnames(elevP)[5]<-"Elevation"

elevP<-merge(pindex,elevP,by.x="Species",by.y="Iplant_Double",keep=all)
```

```{r}
#ID for NA is 1
dath$ID<-as.character(dath$ID)
dath[which(is.na(dath$ID)),"ID"]<-dath$TransectID[which(is.na(dath$ID))]

indatraw<- dath %>% group_by(Bird,Plant,ID,DateP) %>% summarize(Yobs=n(),Elev=mean(ele,na.rm=T)) %>% filter(Plant %in% elevP$Index) %>% ungroup() %>% arrange(desc(Yobs)) %>% mutate(Time=as.numeric(as.factor(as.character(paste(ID,DateP))))) 

#add months and years
indatraw$Month<-as.numeric(factor(months(strptime(indatraw$DateP,format="%Y-%m-%d")),levels=month.name))
indatraw$Year<-years(indatraw$DateP)
```

What elevation transect is each observation in?

```{r}
#which elevation bin is each observation within
labs<-paste(seq(1300,2500,200),seq(1500,2700,200),sep="_")
indatraw$Transect_R<-cut(indatraw$Elev,seq(1300,2700,200),labels=labs)
```

```{r}
indatlong<-acast(indatraw,Bird~Plant~Time~Transect_R,value.var="Yobs")

indatlong[is.na(indatlong)]<-0
```

##Resource availability at each data point

```{r}
#merge with original data, easier to do as factors
indatraw<-as.tbl(indatraw)
indatraw$Time<-as.factor(indatraw$Time)

#flower surveys are done twice a month, get the average
flower.monthD<-flower.month %>% arrange(Month,Year,Transect_R) %>% group_by(Month,Year,Transect_R) %>% summarize(Flowers=mean(Flowers,na.rm=T),Availability=max(as.numeric(as.character(Availability))))

#We lose some data here, needs to be cleaned.
obs<-merge(indatraw,flower.monthD,by=c("Month","Year","Transect_R"))
```


```{r}
#match the traits
for(x in 1:nrow(obs)){
  obs$Traitmatch[x]<-traitmatchT[obs$Bird[x],obs$Plant[x]]
}

#add in hummingbird names
obs<-merge(obs,bindex,by.x="Bird",by.y="Index")
```

#Choosing a distribution
Before we account for elevation and availability, what is the distribution of intensity of interactions?

```{r}
ggplot(indatraw,aes(x=Yobs)) + geom_histogram()
```

If we tend to think of the intensity of events as poisson, our data is extremely ones-inflated. The first moment of the poisson does not well capture the data.

The best fitting moment is in opaque red. The observed data is in black.

```{r}
moment<-fitdistr(indatraw$Yobs,"poisson")
est<-data.frame(Yobs=rpois(n=length(indatraw$Yobs),lambda=moment$estimate[[1]]))
ggplot(indatraw,aes(x=Yobs)) + geom_histogram(fill="black") + geom_histogram(data=est,fill="red",alpha=.4) + theme_bw() + ggtitle("Intensity of interactions")
```

What about negative binomial?

The best fitting moment is in opaque red. The observed data is in black.

```{r}
moment<-fitdistr(indatraw$Yobs,"negative binomial")
est<-data.frame(Yobs=rpois(n=length(indatraw$Yobs),lambda=moment$estimate[[1]]))
ggplot(indatraw,aes(x=Yobs)) + geom_histogram(fill="black") + geom_histogram(data=est,fill="red",alpha=.4) + theme_bw()
```

What about log normal?

```{r}
moment<-fitdistr(indatraw$Yobs,"lognormal")
est<-data.frame(Yobs=rpois(n=length(indatraw$Yobs),lambda=moment$estimate[[1]]))
ggplot(indatraw,aes(x=Yobs)) + geom_histogram(fill="black") + geom_histogram(data=est,fill="red",alpha=.4) + theme_bw()
```

The best fitting moment is in opaque red. The observed data is in black.

Ignoring non-detections for the moment.


#Exploratory Model Fitting

First thought on sampling, take the mean interaction for each bird, plant combination for high and low resource periods. Connect intensity with a line.

```{r}
mobs<-obs[,] %>% group_by(Species,Plant,Availability) %>% summarize(Events=n(),d=mean(Yobs),Traitmatch=unique(Traitmatch))

#merge with names
mobss<-merge(mobs,pindex,by.x="Plant",by.y="Index")
colnames(mobss)<-c("Plant","Species","Availability","Events","d","Traitmatch","Iplant_Double")

ggplot(mobss,aes(x=Traitmatch,y=d,col=as.factor(Availability))) + geom_point(aes(size=Events),alpha=.8) + theme_bw() + facet_wrap(~Species,scales="free") + geom_line(aes(group=Plant),col="black") + scale_size_continuous(range=c(3,7)) + labs(col="Flower Availability")
```

##GLM

No accounting for detection. Also values independent.

```{r}
ggplot(obs[obs$Yobs>0,],aes(y=Yobs,x=Traitmatch)) + geom_jitter() +  stat_smooth(method="glm",family="poisson") + facet_wrap(~Species,scales="free")

mod1<-glm(data=obs,family="poisson",Yobs ~ Traitmatch )
summary(mod1)
```

Mean position overtime

```{r}
mean_obs<-group_by(obs,Species,Plant,Traitmatch) %>% summarize(n=mean(Yobs))
ggplot(mean_obs[,],aes(x=Traitmatch,y=n)) + geom_point() + stat_smooth(method="glm",family="poisson") + facet_wrap(~Species,scale="free") + ggtitle("Species Mean Tendency")
```

```{r}
ggplot(obs,aes(x=Traitmatch,y=Yobs,col=as.factor(Availability))) + geom_point() + geom_smooth(method="glm",family="poisson") + theme_bw() + facet_wrap(~Species,scale="free")
```

##Mixed Effect models
```{r}
#Trait only
traitonly<-glmer(data=obs,Yobs~Traitmatch + (1|Bird),family="poisson")
trait_resource<-glmer(data=obs,Yobs~Traitmatch + scale(Flowers) + (1|Bird) + (1|Plant),family="poisson")
tr_interaction<-glmer(data=obs,Yobs~Traitmatch * scale(Flowers) + (1|Bird) + (1|Plant),family="poisson")

tr_interaction<-glmer(data=obs,Yobs~Traitmatch * Availability + (1|Bird) + (1|Plant),family="poisson")

anova(traitonly,trait_resource,tr_interaction)
summary(tr_interaction)
plot(tr_interaction)
```

##Non-detection

```{r}
#Only non-detections are real 0's, the rest are NA's and are removed.
#Plants not surveyed in that time period
#Hummingbirds not present at that site

for(x in 1:dim(indatlong)[3]){
  #Remove non sampled plants 
  a<-indatlong[,,x,]
  
  #for each elevation
  for (j in 1:dim(a)[3]){
  #No observations at that plant
  toNA<-as.numeric(names(which(apply(a[,,j],2,sum)==0)))
  pres<-as.numeric(names(which(!apply(a[,,j],2,sum)==0)))
  indatlong[,colnames(a[,,j]) %in% toNA,x,j]<-NA
  
  #match elevation if there were presences, slightly terse code.
  if(length(pres)>0){
    for (y in 1:length(pres)){
      #Plant range
      pr<-elevP[elevP$Index %in% pres[y],"Elevation"]
      if(!pr==3){
        helim<-elevH[!elevH$Elevation %in% c(pr,3),"Index"]
        indatlong[helim,colnames(a) %in% pres[y],x,j]<-NA
        }
      }  
    }
  }
}


#melt and remove Na's
indat<-melt(indatlong)
indat<-indat[!is.na(indat$value),]

colnames(indat)<-c("Bird","Plant","Time","Transect_R","Yobs")

#remerge the time period data
Timelookup<-indatraw %>% dplyr::select(Time,DateP,Transect_R,Month,Year)%>% group_by(Time,DateP,Transect_R,Month,Year) %>% distinct() %>% arrange(Time)

#Get time information
indatmerge<-merge(indat,Timelookup,by=c("Time","Transect_R"),all.x=T)
#Get flower information
obsf<-merge(indatmerge,flower.monthD,by=c("Month","Year","Transect_R"))
#Get trait information
#match the traits
for(x in 1:nrow(obsf)){
  obsf$Traitmatch[x]<-traitmatchT[obsf$Bird[x],obsf$Plant[x]]
}
```

##Exploratory model fitting

```{r}
ggplot(obsf,aes(x=Traitmatch,y=(Yobs > 0)*1,col=Flowers)) + geom_point() + scale_color_continuous(low="blue",high="red")+ geom_smooth(method="glm",family="binomial") + facet_wrap(~Bird,scale="free") + theme_bw()
```

```{r}
ggplot(obsf,aes(x=Traitmatch,y=(Yobs > 0)*1,col=Flowers)) + geom_point() + scale_color_continuous(low="blue",high="red")+ geom_smooth(method="glm",family="binomial") + facet_wrap(~Bird,scale="free") + theme_bw()
```

##Mixed Effect models with non-detections
Poisson Counts
```{r}
#Trait only
traitonly<-glmer(data=obsf,Yobs~Traitmatch + (1|Bird),family="poisson")
trait_resource<-glmer(data=obsf,Yobs~Traitmatch + scale(Flowers) + (1|Bird) + (1|Plant),family="poisson")
tr_interaction<-glmer(data=obsf,Yobs~Traitmatch * scale(Flowers) + (1|Bird) + (1|Plant),family="poisson")

tr_interaction<-glmer(data=obsf,Yobs~Traitmatch * Availability + (1|Bird) + (1|Plant),family="poisson")

anova(traitonly,trait_resource,tr_interaction)
summary(tr_interaction)
plot(tr_interaction)
```

Visualize interaction model

```{r}
plot(effect("Traitmatch:Availability", tr_interaction))
```


##Hierarchical Bayesian Model


### Model Fitting

$$ Yobs_{i,j,k} \sim Binom(Detect_i,N_{i,j,k}) $$

$$ N_{i,j,k} \sim Pois(\lambda_{i,j,k}) $$

$$log(\lambda_{i,j,k})<-\alpha_i + \beta_i * abs(Bill_i - Corolla_j) * \beta_2 * Resources_k + \beta_3 * Resources_k * abs(Bill_i - Corolla_j) $$

**Priors**

$$ Detect \sim U(0,1) $$
$$\alpha_i \sim N(intercept,\tau_{\alpha})$$
$$\beta_{1,i} \sim N(\gamma_1i,\tau_{\beta_1})$$
$$\beta_{2,i} \sim N(\gamma_2i,\tau_{\beta_2})$$
$$\beta_{3,i} \sim N(\gamma_3i,\tau_{\beta_3})$$


**Hyperpriors**

Group Level Means

$$\gamma_{1,i} \sim N(0.001,0.001)$$
$$\gamma_{2,i} \sim N(0.001,0.001)$$
$$\gamma_{3,i} \sim N(0.001,0.001)$$
$$ intercept \sim N(0.001,0.001)$$

Group Level Variance

$$\tau_{\alpha} \sim Gamma(0.001,0.001)$$
$$\tau_\beta1 \sim Gamma(0.001,0.001)$$
$$\tau_\beta2 \sim Gamma(0.001,0.001)$$
$$\tau_\beta3 \sim Gamma(0.001,0.001)$$

**Derived quantities**

$$\sigma_{int} = \frac{1}{\tau_{\alpha}}^2$$
$$\sigma_{slope1} = \frac{1}{\tau_{\beta_1}}^2$$
$$\sigma_{slope2} = \frac{1}{\tau_{\beta_2}}^2$$
$$\sigma_{slope3} = \frac{1}{\tau_{\beta_3}}^2$$


```{r,eval=T,strip.white=T}

#Source model
source("Bayesian/NmixturePoissonRagged.R")

#print model
writeLines(readLines("Bayesian/NmixturePoissonRagged.R"))

#Input Data
Dat <- list(
  #Observations
  Yobs=obsf$Yobs,
  Nobs=nrow(obsf),
  
  #indices
  Bird=obsf$Bird,
  Plant=obsf$Plant,
  Time=1:nrow(obsf),
  
  #Length of variables
  Birds=max(obsf$Bird),
  resources=obsf$Availability,
  traitmatch=obsf$Traitmatch)

#Inits
initB<-rep(.5,Dat$Birds)
#Ninit<-array(dim=c(Dat$Birds,Dat$Plants,Dat$Time),data=10)
Ninit<-rep(max(obsf$Yobs),Dat$Nobs)

InitStage <- function(){list(beta1=initB,beta2=initB,detect=initB,beta3=initB,alpha=initB,intercept=0,tau_alpha=0.1,tau_beta1=0.1,tau_beta2=0.1,tau_beta3=0.1,gamma1=0,gamma2=0,gamma3=0,N=Ninit)}

#Parameters to track
ParsStage <- c("alpha","beta1","beta2","beta3","intercept","sigma_int","sigma_slope1","sigma_slope2","sigma_slope3","gamma1","gamma2","gamma3","detect","fit","fitnew")

#MCMC options

ni <- 20000  # number of draws from the posterior
nt <- 2  #thinning rate
nb <- ni*.95 # number to discard for burn-in
nc <- 2  # number of chains

#Jags

m = jags(inits=InitStage,
         n.chains=nc,
         model.file="Bayesian/NmixturePoissonRagged.jags",
         working.directory=getwd(),
         data=Dat,
         parameters.to.save=ParsStage,
         n.thin=nt,
         n.iter=ni,
         n.burnin=nb,
         DIC=T)
```

```{r}
pars<-extract_par(m)
```

###Assess Convergence

```{r,cache=FALSE,eval=TRUE,fig.width=11,fig.height=5}
#Intercept
ggplot(pars[pars$par %in% c("alpha"),],aes(x=Draw,y=estimate,col=as.factor(Chain))) + geom_line() + facet_wrap(~species,scale="free") + theme_bw() + labs(col="Chain") + ggtitle("Detection Probability")

###Slopes
ggplot(pars[pars$par %in% c("alpha","beta1","beta2","beta3"),],aes(x=Draw,y=estimate,col=as.factor(Chain))) + geom_line() + facet_grid(par~species,scale="free") + theme_bw() + labs(col="Chain") + ggtitle("Regression Convergence")

```

```{r,fig.height=5,fig.width=11,eval=T}
ggplot(pars[pars$par %in% c("gamma1","gamma2","gamma3","sigma_int","sigma_slope1","sigma_slope2","sigma_slope3"),],aes(x=Draw,y=estimate,col=as.factor(Chain))) + geom_line() + theme_bw() + labs(col="Chain") + ggtitle("Trait-matching Hierarchical regression") + facet_wrap(~par,scales="free")
```

###Posteriors

Intercept

```{r,cache=FALSE,fig.width=7,fig.height=13}

#intercept
ggplot(pars[pars$par %in% c("alpha"),],aes(x=estimate,fill=as.factor(species))) + geom_histogram() + ggtitle("Estimate of Intercept") + theme_bw() + ggtitle("Species Posteriors")

###Slope Posterior Distributions
psim<-ggplot(pars[pars$par %in% c("beta1","beta2","beta3"),],aes(x=estimate)) + geom_histogram() + ggtitle("Estimate of regression parameters") + facet_grid(species~par,scales="free") + theme_bw() + ggtitle("Species Posteriors")

###Detection Posterior Distributions
ggplot(pars[pars$par %in% c("detect"),],aes(x=estimate)) + geom_histogram() + ggtitle("Estimate of regression parameters") + facet_wrap(~species,scales="free") + theme_bw() + ggtitle("Species Posteriors")

#ggsave("Figures/ObservedPosteriors.jpg",dpi=300,height=8,width=8)
```

```{r,cache=FALSE,eval=TRUE,fig.height=13,fig.width=10}

psim2<-ggplot(pars[pars$par %in% c("gamma1","gamma2","gamma3","intercept","sigma_int","sigma_slope1","sigma_slope2","sigma_slope3"),],aes(x=estimate)) + geom_histogram() + ggtitle("Hierarchical Posteriors") + facet_wrap(~par,scale="free",nrow=2) + theme_bw() 

grid.arrange(psim,psim2,heights=c(.6,.4))
```

###Predicted Relationship 

```{r,fig.height=4,fig.width=4}
#Expand out pars
castdf<-dcast(pars[pars$par %in% c("gamma1","gamma2","gamma3","intercept"),], Chain + Draw~par,value.var="estimate")
```

```{r}
#Trajectories from posterior
predy<-trajF(alpha=castdf$intercept,beta1=castdf$gamma1,x=Dat$traitmatch,resources=Dat$resources,beta2=castdf$gamma2,beta3=castdf$gamma3)

psim3<-ggplot(data=predy,aes(x=x)) + geom_ribbon(aes(ymin=lower,ymax=upper),alpha=0.1,fill="red")  + geom_line(aes(y=mean),size=.8,col="red",linetype="dashed") + theme_bw() + ylab("Interactions") + xlab("Difference between Bill and Corolla Length") + geom_point(data=obsf,aes(x=Traitmatch,y=Yobs))
psim3

#ggsave("Figures/SimulationResults.jpg",height=5,width=6,dpi=300)
```

###Visualize interactions

```{r}
predyint<-intF(alpha=castdf$intercept,beta1=castdf$gamma1,x=Dat$traitmatch,resources=Dat$resources,beta2=castdf$gamma2,beta3=castdf$gamma3)

psim4<-ggplot(data=predyint,aes(x=x)) + geom_ribbon(aes(ymin=lower,ymax=upper),alpha=0.3,fill="black") + theme_bw() + ylab("Effect of Resources on Trait Matching") + geom_line(aes(y=mean),size=.8,col="black",linetype="dashed") + xlab("Difference between Bill and Corolla Length") 

psim4
```

###Species Predictions

```{r}
#orignal data to plot as ppints
odat<-merge(obsf,bindex,by.x="Bird",by.y="Index")
odat<-merge(odat,pindex,by.x="Plant",by.y="Index")
```

```{r,fig.height=10,fig.width=11,eval=T}

castdf<-dcast(pars[pars$par %in% c("beta1","beta2","beta3","alpha"),], species +Chain + plant+ Draw~par,value.var="estimate")

#Turn to 
castdf$species<-factor(castdf$species,levels=1:max(as.numeric(castdf$species)))

species.split<-split(castdf,list(castdf$species),drop = T)

species.traj<-list()

for(d in 1:length(species.split)){
  x<-species.split[[d]]
  index<-unique(x$species)
  
  #get data for those species
  billd<-obsf[obsf$Bird %in% index,]
  
  species.traj[[d]]<-trajF(alpha=x$alpha,beta1=x$beta1,beta2=x$beta2,beta3=x$beta3,resources=billd$Availability,x=billd$Traitmatch)
  }

names(species.traj)<-names(species.split)

species.traj<-melt(species.traj,id.var=colnames(species.traj[[1]]))

#split out names and model
species.traj[,c("Index")]<-colsplit(species.traj$L1,"\\.",c("Index"))

spe<-merge(species.traj,bindex,by.x="Index",by.y="Index")


#match colnames
colnames(odat)[13:14]<-c("Species","Iplant_Double")

#plot and compare to original data
p<-ggplot(data=spe,aes(x=x)) + geom_ribbon(aes(ymin=lower,ymax=upper),alpha=0.2) + geom_line(aes(y=mean),size=1) + theme_bw() + ylab("Interactions")+ xlab("Difference between Bill and Corolla Length") + facet_wrap(~Species,scales="free",ncol=3) + geom_point(data=odat,aes(x=Traitmatch,y=Yobs))

print(p)
```

###Species Level Interaction

```{r,fig.height=10,fig.width=11,eval=T}

castdf<-dcast(pars[pars$par %in% c("beta1","beta2","beta3","alpha"),], species +Chain + plant+ Draw~par,value.var="estimate")

#Turn to 
castdf$species<-factor(castdf$species,levels=1:max(as.numeric(castdf$species)))

species.split<-split(castdf,list(castdf$species),drop = T)

species.traj<-list()

for(d in 1:length(species.split)){
  dat<-species.split[[d]]
  index<-unique(dat$species)
  
  #get data for those species
  billd<-obsf[obsf$Bird %in% index,]
  
  #Calculate interaction effect
  species.traj[[d]]<-intF(alpha=dat$alpha,beta1=dat$beta1,x=billd$Traitmatch,resources=billd$Availability,beta2=dat$beta2,beta3=dat$beta3)
  
  }

names(species.traj)<-names(species.split)

species.traj<-melt(species.traj,id.var=colnames(species.traj[[1]]))

#split out names and model
species.traj[,c("Index")]<-colsplit(species.traj$L1,"\\.",c("Index"))

spe<-merge(species.traj,bindex,by.x="Index",by.y="Index")


#match colnames
colnames(odat)[13:14]<-c("Species","Iplant_Double")

#plot and compare to original data
p<-ggplot(data=spe,aes(x=x)) + geom_ribbon(aes(ymin=lower,ymax=upper,fill=Species),alpha=0.2) + geom_line(aes(y=mean,col=Species),size=1) + theme_bw() + ylab("Interactions")+ xlab("Difference between Bill and Corolla Length")  + ylab("Effect of Resources on Trait Matching") 

print(p)
```


###Posterior Check

```{r,fig.height=4,fig.width=8,eval=T}

fitstat<-droplevels(pars[pars$par %in% c("fit","fitnew"),])
fitstat<-dcast(fitstat[,-c(1,5,6)],Draw+Chain~par,value.var="estimate")

#add 1:1 line
ymin<-round(min(c(fitstat$fit,fitstat$fitnew)))
ymax<-round(max(c(fitstat$fit,fitstat$fitnew)))
ab<-data.frame(x=ymin:ymax,y=ymin:ymax)

p<-ggplot(fitstat,aes(x=fit,y=fitnew)) + geom_point() + theme_bw() + coord_equal()
psim5<-p  + labs(x="Discrepancy of observed data",y="Discrepancy of replicated data",col="Model") + geom_line(data=ab,aes(x=x,y=y)) + ggtitle("Simulated Data")

psim5
```

#Alternative Models

Perhaps the intensity of the visit (number of visits per day), is more driven by local factors such as individual plan vigor, camera placement, or other variables not captured in the model. In this case, we care more about the probability of an occurrence happening, and some species are more detectable. We are losing information, but it may decrease noise.

##Mixed Effect models with non-detections
Binary Logistic Counts
```{r}
obsf$Binary<-(obsf$Yobs>0)*1
#Trait only
traitonly<-glmer(data=obsf,Binary~Traitmatch + (1|Bird),family="binomial")
trait_resource<-glmer(data=obsf,Binary~Traitmatch + scale(Flowers) + (1|Bird) + (1|Plant),family="binomial")
tr_interaction<-glmer(data=obsf,Binary~Traitmatch * scale(Flowers) + (1|Bird) + (1|Plant),family="binomial")

tr_interaction<-glmer(data=obsf,Binary~Traitmatch * Availability + (1|Bird) + (1|Plant),family="binomial")

anova(traitonly,trait_resource,tr_interaction)
summary(tr_interaction)

```

##Hierarchical Bayesian Model
### Model Notation

$$ Yobs_{i,j,k} \sim Bern(Detect_i) * truestate_{i,j,k}) $$

$$ truestate_{i,j,k} \sim Bern(\lambda_{i,j,k}) $$

$$logit(\p_{i,j,k})<-\alpha_i + \beta_i * abs(Bill_i - Corolla_j) * \beta_2 * Resources_k + \beta_3 * Resources_k * abs(Bill_i - Corolla_j) $$

**Priors**

$$ Detect \sim U(0,1) $$
$$\alpha_i \sim N(intercept,\tau_{\alpha})$$
$$\beta_{1,i} \sim N(\gamma_1i,\tau_{\beta_1})$$
$$\beta_{2,i} \sim N(\gamma_2i,\tau_{\beta_2})$$
$$\beta_{3,i} \sim N(\gamma_3i,\tau_{\beta_3})$$


**Hyperpriors**

Group Level Means

$$\gamma_{1,i} \sim N(0.001,0.001)$$
$$\gamma_{2,i} \sim N(0.001,0.001)$$
$$\gamma_{3,i} \sim N(0.001,0.001)$$
$$ intercept \sim N(0.001,0.001)$$

Group Level Variance

$$\tau_{\alpha} \sim Gamma(0.001,0.001)$$
$$\tau_\beta1 \sim Gamma(0.001,0.001)$$
$$\tau_\beta2 \sim Gamma(0.001,0.001)$$
$$\tau_\beta3 \sim Gamma(0.001,0.001)$$

**Derived quantities**

$$\sigma_{int} = \frac{1}{\tau_{\alpha}}^2$$
$$\sigma_{slope1} = \frac{1}{\tau_{\beta_1}}^2$$
$$\sigma_{slope2} = \frac{1}{\tau_{\beta_2}}^2$$
$$\sigma_{slope3} = \frac{1}{\tau_{\beta_3}}^2$$


```{r,eval=T,strip.white=T}

#Source model
source("Bayesian/OccupancyModelRagged.R")

#print model
writeLines(readLines("Bayesian/OccupancyModelRagged.R"))

#Input Data
Dat <- list(
  #Observations
  Yobs=obsf$Binary,
  Nobs=nrow(obsf),
  
  #indices
  Bird=obsf$Bird,
  Plant=obsf$Plant,
  Time=1:nrow(obsf),
  
  #Length of variables
  Birds=max(obsf$Bird),
  resources=obsf$Availability,
  traitmatch=obsf$Traitmatch)

#Inits
initB<-rep(.5,Dat$Birds)
Ninit<-rep(1,Dat$Nobs)

InitStage <- function(){list(beta1=initB,beta2=initB,detect=initB,beta3=initB,alpha=initB,intercept=0,tau_alpha=0.1,tau_beta1=0.1,tau_beta2=0.1,tau_beta3=0.1,gamma1=0,gamma2=0,gamma3=0,true_state=Ninit)}

#Parameters to track
ParsStage <- c("alpha","beta1","beta2","beta3","intercept","sigma_int","sigma_slope1","sigma_slope2","sigma_slope3","gamma1","gamma2","gamma3","detect","eff.p","fit","fitnew","p")

#MCMC options

ni <- 20000  # number of draws from the posterior
nt <- 2  #thinning rate
nb <- ni*.95 # number to discard for burn-in
nc <- 2  # number of chains

#Jags

m = jags(inits=InitStage,
         n.chains=nc,
         model.file="Bayesian/OccupancyModelRagged.jags",
         working.directory=getwd(),
         data=Dat,
         parameters.to.save=ParsStage,
         n.thin=nt,
         n.iter=ni,
         n.burnin=nb,
         DIC=T)
```

```{r}
pars<-extract_par(m)
```

###Assess Convergence

```{r,cache=FALSE,eval=TRUE,fig.width=11,fig.height=5}
#Intercept
ggplot(pars[pars$par %in% c("alpha"),],aes(x=Draw,y=estimate,col=as.factor(Chain))) + geom_line() + facet_wrap(~species,scale="free") + theme_bw() + labs(col="Chain") + ggtitle("Detection Probability")

###Slopes
ggplot(pars[pars$par %in% c("alpha","beta1","beta2","beta3"),],aes(x=Draw,y=estimate,col=as.factor(Chain))) + geom_line() + facet_grid(par~species,scale="free") + theme_bw() + labs(col="Chain") + ggtitle("Regression Convergence")

```

```{r,fig.height=5,fig.width=11,eval=T}
ggplot(pars[pars$par %in% c("gamma1","gamma2","gamma3","sigma_int","sigma_slope1","sigma_slope2","sigma_slope3"),],aes(x=Draw,y=estimate,col=as.factor(Chain))) + geom_line() + theme_bw() + labs(col="Chain") + ggtitle("Trait-matching Hierarchical regression") + facet_wrap(~par,scales="free")
```

###Posteriors

Intercept

```{r,cache=FALSE,fig.width=7,fig.height=13}

#intercept
ggplot(pars[pars$par %in% c("alpha"),],aes(x=estimate,fill=as.factor(species))) + geom_histogram() + ggtitle("Estimate of Intercept") + theme_bw() + ggtitle("Species Posteriors")

###Slope Posterior Distributions
psim<-ggplot(pars[pars$par %in% c("beta1","beta2","beta3"),],aes(x=estimate)) + geom_histogram() + ggtitle("Estimate of regression parameters") + facet_grid(species~par,scales="free") + theme_bw() + ggtitle("Species Posteriors")

###Detection Posterior Distributions
ggplot(pars[pars$par %in% c("detect"),],aes(x=estimate)) + geom_histogram() + ggtitle("Estimate of regression parameters") + facet_wrap(~species,scales="free") + theme_bw() + ggtitle("Species Posteriors")

#ggsave("Figures/ObservedPosteriors.jpg",dpi=300,height=8,width=8)
```

```{r,cache=FALSE,eval=TRUE,fig.height=13,fig.width=12}

psim2<-ggplot(pars[pars$par %in% c("gamma1","gamma2","gamma3","intercept","sigma_int","sigma_slope1","sigma_slope2","sigma_slope3"),],aes(x=estimate)) + geom_histogram() + ggtitle("Hierarchical Posteriors") + facet_wrap(~par,scale="free",nrow=2) + theme_bw() 
psim2
```

###Predicted Relationship 

```{r,fig.height=4,fig.width=4}
#Expand out pars
castdf<-dcast(pars[pars$par %in% c("gamma1","gamma2","gamma3","intercept"),], Chain + Draw~par,value.var="estimate")
```

```{r}
#Trajectories from posterior
predy<-trajF(alpha=castdf$intercept,beta1=castdf$gamma1,x=Dat$traitmatch,resources=Dat$resources,beta2=castdf$gamma2,beta3=castdf$gamma3)

psim3<-ggplot(data=predy,aes(x=x)) + geom_ribbon(aes(ymin=lower,ymax=upper),alpha=0.1,fill="red")  + geom_line(aes(y=mean),size=.8,col="red",linetype="dashed") + theme_bw() + ylab("Probability of Interaction") + xlab("Difference between Bill and Corolla Length") + geom_point(data=obsf,aes(x=Traitmatch,y=Binary)) + ylim(0,1)
psim3

#ggsave("Figures/SimulationResults.jpg",height=5,width=6,dpi=300)
```

###Visualize interactions

```{r}
predyint<-intF(alpha=castdf$intercept,beta1=castdf$gamma1,x=Dat$traitmatch,resources=Dat$resources,beta2=castdf$gamma2,beta3=castdf$gamma3)

psim4<-ggplot(data=predyint,aes(x=x)) + geom_ribbon(aes(ymin=lower,ymax=upper),alpha=0.3,fill="black") + theme_bw() + ylab("Effect of Resources on Trait Matching") + geom_line(aes(y=mean),size=.8,col="black",linetype="dashed") + xlab("Difference between Bill and Corolla Length") 

psim4
```

###Species Predictions

```{r}
#orignal data to plot as ppints
odat<-merge(obsf,bindex,by.x="Bird",by.y="Index")
odat<-merge(odat,pindex,by.x="Plant",by.y="Index")
```

```{r,fig.height=10,fig.width=12,eval=T}

castdf<-dcast(pars[pars$par %in% c("beta1","beta2","beta3","alpha"),], species +Chain + plant+ Draw~par,value.var="estimate")

#Turn to 
castdf$species<-factor(castdf$species,levels=1:max(as.numeric(castdf$species)))

species.split<-split(castdf,list(castdf$species),drop = T)

species.traj<-list()

for(d in 1:length(species.split)){
  x<-species.split[[d]]
  index<-unique(x$species)
  
  #get data for those species
  billd<-obsf[obsf$Bird %in% index,]
  
  species.traj[[d]]<-trajF(alpha=x$alpha,beta1=x$beta1,beta2=x$beta2,beta3=x$beta3,resources=billd$Availability,x=billd$Traitmatch)
  }

names(species.traj)<-names(species.split)

species.traj<-melt(species.traj,id.var=colnames(species.traj[[1]]))

#split out names and model
species.traj[,c("Index")]<-colsplit(species.traj$L1,"\\.",c("Index"))

spe<-merge(species.traj,bindex,by.x="Index",by.y="Index")


#match colnames
colnames(odat)[13:14]<-c("Species","Iplant_Double")

#plot and compare to original data
p<-ggplot(data=spe,aes(x=x)) + geom_ribbon(aes(ymin=lower,ymax=upper),alpha=0.2) + geom_line(aes(y=mean),size=1) + theme_bw() + ylab("Interactions")+ xlab("Difference between Bill and Corolla Length") + facet_wrap(~Species,scales="free",ncol=3) + geom_point(data=odat,aes(x=Traitmatch,y=Binary))

print(p)
```

###Species Level Interaction

```{r,fig.height=10,fig.width=11,eval=T}

castdf<-dcast(pars[pars$par %in% c("beta1","beta2","beta3","alpha"),], species +Chain + plant+ Draw~par,value.var="estimate")

#Turn to 
castdf$species<-factor(castdf$species,levels=1:max(as.numeric(castdf$species)))

species.split<-split(castdf,list(castdf$species),drop = T)

species.traj<-list()

for(d in 1:length(species.split)){
  dat<-species.split[[d]]
  index<-unique(dat$species)
  
  #get data for those species
  billd<-obsf[obsf$Bird %in% index,]
  
  #Calculate interaction effect
  species.traj[[d]]<-intF(alpha=dat$alpha,beta1=dat$beta1,x=billd$Traitmatch,resources=billd$Availability,beta2=dat$beta2,beta3=dat$beta3)
  
  }

names(species.traj)<-names(species.split)

species.traj<-melt(species.traj,id.var=colnames(species.traj[[1]]))

#split out names and model
species.traj[,c("Index")]<-colsplit(species.traj$L1,"\\.",c("Index"))

spe<-merge(species.traj,bindex,by.x="Index",by.y="Index")


#match colnames
colnames(odat)[13:14]<-c("Species","Iplant_Double")

#plot and compare to original data
p<-ggplot(data=spe,aes(x=x)) + geom_ribbon(aes(ymin=lower,ymax=upper,fill=Species),alpha=0.2) + geom_line(aes(y=mean,col=Species),size=1) + theme_bw() + ylab("Interactions")+ xlab("Difference between Bill and Corolla Length")  + ylab("Effect of Resources on Trait Matching") 

print(p)
```


###Posterior Check

```{r,fig.height=4,fig.width=8,eval=T}

fitstat<-droplevels(pars[pars$par %in% c("fit","fitnew"),])
fitstat<-dcast(fitstat[,-c(1,5,6)],Draw+Chain~par,value.var="estimate")

#add 1:1 line
ymin<-round(min(c(fitstat$fit,fitstat$fitnew)))
ymax<-round(max(c(fitstat$fit,fitstat$fitnew)))
ab<-data.frame(x=ymin:ymax,y=ymin:ymax)

p<-ggplot(fitstat,aes(x=fit,y=fitnew)) + geom_point() + theme_bw() + coord_equal()
psim5<-p  + labs(x="Discrepancy of observed data",y="Discrepancy of replicated data",col="Model") + geom_line(data=ab,aes(x=x,y=y)) + ggtitle("Simulated Data")

psim5
```


```{r}
save.image("Observed.RData")
```
