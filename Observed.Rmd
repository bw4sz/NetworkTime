---
title: Niche overlap increases with increasing resource availability in a tropical
  plant-pollinator network.
author: "Ben Weinstein"
date: "Tuesday, October 14, 2014"
output:
  html_document:
    toc: true
    theme: spacelab
  word_document: default
  keep_md: true
---

#Aim
Which birds use which plants? What are the mechanisms that determine niche overlap in this assemblage.

We will fit several difference types of models and ask how they inform our understanding. For each model, we try to calculate a measure of discrepancy and assess model fit.

##Data

* Using automated cameras and transects, we have been recording flower visitation rates by each hummingbird species for two years.
* We have bill and corolla lengths for each species of bird and flower.
* We have been collecting phenology data on available resources

Birds use flowers that have similar length of bill shape and we expect the importance of trait matching to decrease as available resources increase.

```{r,echo=FALSE,warning=FALSE,message=FALSE}
library(knitr)
library(R2jags)
library(reshape2)
library(ggplot2)
library(scales)
library(dplyr)
library(stringr)
library(lme4)
library(picante)
library(igraph)
library(bipartite)
library(effects)
library(chron)
library(gridExtra)
library(MASS)
library(boot)

#Set Dropbox Location
#setwd to dropbox
droppath<-"C:/Users/Ben/Dropbox/"

#Set github path
gitpath<-"C:/Users/Ben/Documents/NetworkTime/"

setwd(gitpath)

opts_chunk$set(message=FALSE,warning=FALSE,fig.height=9,fig.width=13,echo=FALSE,cache=F, fig.path='figure/')

#source bayes functions
source("Bayesian/BayesFunctions.R")
```

```{r,eval=F}
#load data is needed
load("Observed.RData")
```

#Read in Data
```{r}
#read in flower morphology data, comes from Nectar.R
droppath<-"C:/Users/Ben/Dropbox/"
fl.morph<-read.csv(paste(droppath,"Thesis/Maquipucuna_SantaLucia/Results/FlowerMorphology.csv",sep=""))

#First row is empty
fl.morph<-fl.morph[-1,]

fl.morph[fl.morph$Group.1 %in%"Drymonia teuscheri","Group.1"]<-"Alloplectus teuscheri"

#Bring in Hummingbird Morphology Dataset, comes from
hum.morph<-read.csv(paste(droppath,"Thesis/Maquipucuna_SantaLucia/Results/HummingbirdMorphology.csv",sep=""))

#Bring in Interaction Matrix
int<-read.csv(paste(droppath,"Thesis/Maquipucuna_SantaLucia/Results/Network/HummingbirdInteractions.csv",sep=""),row.names=1)

#Correct known taxonomic errors
int[int$Iplant_Double=="Alloplectus purpureus","Iplant_Double"]<-"Glossoloma purpureum"
int[int$Iplant_Double=="Capanea affinis","Iplant_Double"]<-"Kohleria affinis"
int[int$Iplant_Double=="Columnea cinerea","Iplant_Double"]<-"Columnea mastersonii"


m.dat<-droplevels(int[colnames(int) %in% c("ID","Video","Time","Hummingbird","Sex","TransectID","Transect_R","Iplant_Double","Pierce","DateP","Month","ele","Type")])


m.dat$Year<-years(as.Date(m.dat$DateP))
#one missing date
m.dat$Year[m.dat$Year %in% 2012]<-2013

#Fix spacing to match clades
#Which are matching
levels(m.dat$Hummingbird)[!levels(m.dat$Hummingbird) %in% hum.morph$English]

#This needs to be checked
#print(paste(levels(m.dat$Hummingbird)[!levels(m.dat$Hummingbird) %in% hum.morph$English],"not matched"))

#Number of bird species
h_species<-nlevels(m.dat$Hummingbird)

#Number of plant species
plant_species<-nlevels(m.dat$Iplant_Double)

#Get english name
dath<-merge(m.dat,hum.morph, by.x="Hummingbird",by.y="English",keep=all)

#Merge to flowers
int.FLlevels<-levels(factor(dath$Iplant_Double))

#Which flowers are we missing info for?
missingTraits<-int.FLlevels[!int.FLlevels %in% fl.morph$X]

print(paste("Missing Trait Information:",missingTraits))
dath<-merge(dath,fl.morph, by.x="Iplant_Double",by.y="X")

#Drop piercing events, since they don't represent correlation
dath<-dath[!dath$Pierce %in% c("y","Y"),]
```

#Available Resources

```{r}
#read in flower totals from FlowerTransects.R
fltransects<-read.csv(paste(droppath,"Thesis/Maquipucuna_SantaLucia/Results/FlowerTransects/FlowerTransectClean.csv",sep=""))

#dates need a bit of formatting
fltransects$DateP<-as.POSIXlt(fltransects$Date,format="%d/%m/%y")

#which are NA needs to date/month reversed. ugly.
fltransects[which(is.na(fltransects$DateP)),"DateP"]<-as.character(as.POSIXlt(as.character(fltransects[which(is.na(fltransects$DateP)),"Date"]),format="%m/%d/%Y"))

#remove withour elevation records (less than 1% of data)
fltransects<-fltransects[!is.na(fltransects$ele),]

#month should be capital 
colnames(fltransects)[colnames(fltransects) %in% "month"]<-"Month"

#Count of flowers per month
fltransects$DateP<-as.character(fltransects$DateP)
flower.month<-group_by(fltransects,Month,Year,Transect_R,Date_F) %>% dplyr::summarise(Flowers=sum(Total_Flowers,na.rm=TRUE))  %>% filter(Flowers>20)
  
#Make month abbreviation column, with the right order
flower.month$Month.a<-factor(month.abb[flower.month$Month],month.abb[c(1:12)])

#Make year factor column
flower.month$Year<-as.factor(flower.month$Year)

#get quantile for each transect
thresh<-melt(group_by(flower.month,Transect_R) %>% summarize(Threshold=quantile(log(Flowers),0.8)) )
flower.month<-merge(flower.month,thresh)
flower.month$Availability<-as.factor((log(flower.month$Flowers)>flower.month$value) * 1)
#plot
ggplot(flower.month,aes(x=Month.a,log(Flowers),shape=as.factor(Year),col=Availability)) + geom_point(size=3) + theme_bw()  + geom_smooth(aes(group=1)) + ylab("Flowers") + xlab("Month") + facet_wrap(~Transect_R,scales="free_y") + labs(shape="Year", y= "Log Available Flowers") + scale_x_discrete(breaks=month.abb[seq(1,12,2)]) + scale_color_manual(labels=c("Low","High"),values=c("black","red")) + labs(col="Resource Availability")

#turn min and max eelvation into seperate columns for the range
flower.month$minElev<-as.numeric(str_extract(flower.month$Transect_R,"(\\d+)"))
flower.month$maxElev<-as.numeric(str_match(flower.month$Transect_R,"(\\d+)_(\\d+)")[,3])

```

### What is the temporal distribution of resources?
```{r}
#moment 
moment<-fitdistr(flower.month$Flowers,"log-normal")

est<-data.frame(x=seq(0,max(flower.month$Flowers),100),Flowers=dlnorm(x=seq(0,max(flower.month$Flowers),100),meanlog=moment$estimate[1],sdlog=moment$estimate[2]))
ggplot(flower.month,aes(x=Flowers)) + geom_density(fill="black") + geom_line(data=est,aes(x=x,y=Flowers),col='red') + theme_bw() + labs(x="Total Monthly Available Resources",y="Density") + ggtitle("Resources are exponentially distributed over time")
```

Appears to be a log normal distribution with the existance of rare, but intense, pulses.

##Match Species to Morphology

```{r}
#remove species with less than  10 observations
keep<-names(which(table(dath$Hummingbird) > 10))

dath<-droplevels(dath[dath$Hummingbird %in% keep,])

#observed traitmatching
traitmatchF<-abs(t(sapply(hum.morph$Bill,function(x){x-fl.morph$TotalCorolla})))

rownames(traitmatchF)<-hum.morph$English
colnames(traitmatchF)<-fl.morph$Group.1
```

```{r}
#match names
#Round to 2 decimals
#Convert to cm for winbugs, avoids numerical underflow
traitmatchT<-round(traitmatchF[rownames(traitmatchF) %in% dath$Hummingbird,colnames(traitmatchF) %in% dath$Iplant_Double],2)/10
```

```{r}
#Formatting indexes
dath$Bird<-as.numeric(factor(dath$Hummingbird,sort(unique(dath$Hummingbird))))
dath$Plant<-as.numeric(factor(dath$Iplant_Double,sort(unique(dath$Iplant_Double))))
dath$obs<-1

traitmatchT<-traitmatchT[sort(rownames(traitmatchT)),sort(colnames(traitmatchT))]

#Create an index to connect to species names
#remerge species levels
bindex<-data.frame(Index=1:length(rownames(traitmatchT)),Species=rownames(traitmatchT))

pindex<-data.frame(Index=1:length(colnames(traitmatchT)),Species=colnames(traitmatchT))
```

###Elevation ranges

Create a binary variable whether each observation was in a low elevation or high elevation transect. We have some species that just occur at the top of the gradient, and are not present in the sampling window of flowers at the low elevation.

Accounting for non-availability.
We have to figure out which plants were sampled in which periods, and if it was sampled, the non-detection are 0 if it wasn't the non-detection are NA. then remove all the Na's.

```{r}
elevH<-read.csv("InputData/HummingbirdElevation.csv",row.names=1)
head(elevH)
colnames(elevH)[5]<-"Elevation"

#merge to names
elevH<-merge(bindex,elevH,by.x="Species",by.y="Hummingbird")

#remove plant species without dual names
keepp<-colnames(traitmatchT)[which(!sapply(strsplit(colnames(traitmatchT), " "), length)==1)]

#high elevation or low elevation
elevP<-read.csv("InputData/PlantElevation.csv",row.names=1)
elevP<-elevP[elevP$Iplant_Double %in% keepp,]
colnames(elevP)[5]<-"Elevation"

elevP<-merge(pindex,elevP,by.x="Species",by.y="Iplant_Double",keep=all)
```

```{r}
#ID for NA is 1
dath$ID<-as.character(dath$ID)
dath[which(is.na(dath$ID)),"ID"]<-dath$TransectID[which(is.na(dath$ID))]

indatraw<- dath %>% group_by(Bird,Plant,ID,DateP) %>% summarize(Yobs=n(),Elev=mean(ele,na.rm=T)) %>% filter(Plant %in% elevP$Index) %>% ungroup() %>% arrange(desc(Yobs)) %>% mutate(Time=as.numeric(as.factor(as.character(paste(ID,DateP))))) 

#add months and years
indatraw$Month<-as.numeric(factor(months(strptime(indatraw$DateP,format="%Y-%m-%d")),levels=month.name))
indatraw$Year<-years(indatraw$DateP)
```

What elevation transect is each observation in?

```{r}
#which elevation bin is each observation within
labs<-paste(seq(1300,2500,200),seq(1500,2700,200),sep="_")
indatraw$Transect_R<-cut(indatraw$Elev,seq(1300,2700,200),labels=labs)
```

```{r}
indatlong<-acast(indatraw,Bird~Plant~Time~Transect_R,value.var="Yobs")

indatlong[is.na(indatlong)]<-0
```

##Resource availability at each data point

```{r}
#merge with original data, easier to do as factors
indatraw<-as.tbl(indatraw)
indatraw$Time<-as.factor(indatraw$Time)

#flower surveys are done twice a month, get the average
flower.monthD<-flower.month %>% arrange(Month,Year,Transect_R) %>% group_by(Month,Year,Transect_R) %>% summarize(Flowers=mean(Flowers,na.rm=T),Availability=max(as.numeric(as.character(Availability))))

#We lose some data here, needs to be cleaned.
obs<-merge(indatraw,flower.monthD,by=c("Month","Year","Transect_R"))
```


```{r}
#match the traits
for(x in 1:nrow(obs)){
  obs$Traitmatch[x]<-traitmatchT[obs$Bird[x],obs$Plant[x]]
}

#add in hummingbird names
obs<-merge(obs,bindex,by.x="Bird",by.y="Index")
```

##Elevation ranges
How much do the bird and plant elevation range match? Using the transect data we will take the absolute value of the difference in mean elevation for each species pair.

```{r}
obs$ElevD<-NA

#Difference in mean elevations

for (x in 1:nrow(obs)){
  b<-obs[x,"Bird"]
  p<-obs[x,"Plant"]
  d<-abs(elevP[p,"m"] - elevH[b,"m"])
  obs[x,"ElevD"]<-d
}
```

#Choosing a response distribution
Before we account for elevation and availability, what is the distribution of intensity of interactions?

```{r}
ggplot(indatraw,aes(x=Yobs)) + geom_histogram()
```

If we tend to think of the intensity of events as poisson, our data is extremely ones-inflated. The first moment of the poisson does not well capture the data.

The best fitting moment is in opaque red. The observed data is in black.

```{r}
moment<-fitdistr(indatraw$Yobs,"poisson")
est<-data.frame(Yobs=rpois(n=length(indatraw$Yobs),lambda=moment$estimate[[1]]))
ggplot(indatraw,aes(x=Yobs)) + geom_histogram(fill="black") + geom_histogram(data=est,fill="red",alpha=.4) + theme_bw() + ggtitle("Intensity of interactions")
```

What about negative binomial?

The best fitting moment is in opaque red. The observed data is in black.

```{r}
moment<-fitdistr(indatraw$Yobs,"negative binomial")
est<-data.frame(Yobs=rpois(n=length(indatraw$Yobs),lambda=moment$estimate[[1]]))
ggplot(indatraw,aes(x=Yobs)) + geom_histogram(fill="black") + geom_histogram(data=est,fill="red",alpha=.4) + theme_bw()
```

What about log normal?

```{r}
moment<-fitdistr(indatraw$Yobs,"lognormal")
est<-data.frame(Yobs=rpois(n=length(indatraw$Yobs),lambda=moment$estimate[[1]]))
ggplot(indatraw,aes(x=Yobs)) + geom_histogram(fill="black") + geom_histogram(data=est,fill="red",alpha=.4) + theme_bw()
```

The best fitting moment is in opaque red. The observed data is in black.

Ignoring non-detections for the moment.


#Exploratory Model Fitting

First thought on sampling, take the mean interaction for each bird, plant combination for high and low resource periods. Connect intensity with a line.

##Intensity as a function of traits
```{r}
mobs<-obs[,] %>% group_by(Species,Plant,Availability) %>% summarize(Events=n(),d=mean(Yobs),Traitmatch=unique(Traitmatch))

#merge with names
mobss<-merge(mobs,pindex,by.x="Plant",by.y="Index")
colnames(mobss)<-c("Plant","Species","Availability","Events","d","Traitmatch","Iplant_Double")

ggplot(mobss,aes(x=Traitmatch,y=d,col=as.factor(Availability))) + geom_point(aes(size=Events),alpha=.8) + theme_bw() + facet_wrap(~Species,scales="free") + geom_line(aes(group=Plant),col="black") + scale_size_continuous(range=c(3,7)) + labs(col="Flower Availability")
```

##Intensity as a function of resources

```{r}
mobs<-obs[,] %>% group_by(Species,Plant,Month,Transect_R) %>% summarize(Events=n(),d=mean(Yobs),Traitmatch=unique(Traitmatch),Flowers=mean(Flowers))

#merge with names
mobss<-merge(mobs,pindex,by.x="Plant",by.y="Index")
colnames(mobss)<-c("Plant","Species","Month","Transect_R","Events","d","Traitmatch","Flowers","Iplant_Double")

ggplot(mobss,aes(x=Flowers,y=d,col=Traitmatch)) + geom_point(aes(size=Events),alpha=.8) + theme_bw() + facet_wrap(~Species,scales="free") + scale_color_continuous(low="blue",high="red") + geom_smooth(method="glm",family="poisson")
```

##Intensity as a function of elevation range

```{r}
mobs<-obs[,] %>% group_by(Species,Plant) %>% summarize(Events=n(),d=mean(Yobs),Traitmatch=unique(Traitmatch),ElevD=mean(ElevD))

#merge with names
mobss<-merge(mobs,pindex,by.x="Plant",by.y="Index")
colnames(mobss)<-c("Plant","Species","Events","d","Traitmatch","ElevD","Iplant_Double")

ggplot(mobss,aes(x=ElevD,y=d,col=Traitmatch)) + geom_point(aes(size=Events),alpha=.8) + theme_bw() + facet_wrap(~Species,scales="free") + scale_color_continuous(low="blue",high="red") + geom_smooth(method="glm",family="poisson") + geom_text(aes(label=Iplant_Double),size=3)
```

##Mixed Effect models

First look at the importance of predictors on intensity of interaction. These data do NOT yet include 0's. 

```{r}
#Trait only
traitonly<-glmer(data=obs,Yobs~Traitmatch + (1|Bird),family="poisson")
trait_resource<-glmer(data=obs,Yobs~Traitmatch + Availability + (1|Bird) + (1|Plant),family="poisson")
trait_resource<-glmer(data=obs,Yobs~Traitmatch + Availability + (1|Bird) + (1|Plant),family="poisson")

tr_interaction<-glmer(data=obs,Yobs~Traitmatch * Availability + (1|Bird) + (1|Plant),family="poisson")

mall<-glmer(data=obs,Yobs~scale(ElevD) + Traitmatch * Availability + (1|Bird) + (1|Plant),family="poisson")

anova(traitonly,trait_resource,tr_interaction)
summary(tr_interaction)
summary(mall)
```

#Absences - accounting for non-detection

We have more information than just the presences, given species elevation ranges, we have absences as well. Absences are birds that occur at the elevation of the plant sample, but were not recorded feeding on the flower.

```{r}
#Only non-detections are real 0's, the rest are NA's and are removed.
#Plants not surveyed in that time period
#Hummingbirds not present at that site

for(x in 1:dim(indatlong)[3]){
  #Remove non sampled plants 
  a<-indatlong[,,x,]
  
  #for each elevation
  for (j in 1:dim(a)[3]){
  #No observations at that plant
  toNA<-as.numeric(names(which(apply(a[,,j],2,sum)==0)))
  pres<-as.numeric(names(which(!apply(a[,,j],2,sum)==0)))
  indatlong[,colnames(a[,,j]) %in% toNA,x,j]<-NA
  
  #match elevation if there were presences, slightly terse code.
  if(length(pres)>0){
    for (y in 1:length(pres)){
      #Plant range
      pr<-elevP[elevP$Index %in% pres[y],"Elevation"]
      if(!pr==3){
        helim<-elevH[!elevH$Elevation %in% c(pr,3),"Index"]
        indatlong[helim,colnames(a) %in% pres[y],x,j]<-NA
        }
      }  
    }
  }
}


#melt and remove Na's
indat<-melt(indatlong)
indat<-indat[!is.na(indat$value),]

colnames(indat)<-c("Bird","Plant","Time","Transect_R","Yobs")

#remerge the time period data
Timelookup<-indatraw %>% dplyr::select(Time,DateP,Transect_R,Month,Year)%>% group_by(Time,DateP,Transect_R,Month,Year) %>% distinct() %>% arrange(Time)

#Get time information
indatmerge<-merge(indat,Timelookup,by=c("Time","Transect_R"),all.x=T)
#Get flower information
obsf<-merge(indatmerge,flower.monthD,by=c("Month","Year","Transect_R"))

#Get trait information
#match the traits
for(x in 1:nrow(obsf)){
  obsf$Traitmatch[x]<-traitmatchT[obsf$Bird[x],obsf$Plant[x]]
}

#Get elevation information
obsf$ElevD<-NA

#Difference in mean elevations

for (x in 1:nrow(obsf)){
  b<-obsf[x,"Bird"]
  p<-obsf[x,"Plant"]
  d<-abs(elevP[p,"m"] - elevH[b,"m"])
  obsf[x,"ElevD"]<-d
}
```



##Exploratory model fitting

Let's look at the same figures as above, with the addition of informed 0's for non-detections.


##Intensity as a function of traits
```{r}
mobs<-obsf[,] %>% group_by(Bird,Plant,Availability) %>% summarize(Events=n(),d=mean(Yobs),Traitmatch=unique(Traitmatch))

#merge with names
mobss<-merge(mobs,pindex,by.x="Plant",by.y="Index")
colnames(mobss)<-c("Plant","Species","Availability","Events","d","Traitmatch","Iplant_Double")

ggplot(mobss,aes(x=Traitmatch,y=d,col=as.factor(Availability))) + geom_point(aes(size=Events),alpha=.8) + theme_bw() + facet_wrap(~Species,scales="free") + geom_line(aes(group=Plant),col="black") + scale_size_continuous(range=c(2,6)) + labs(col="Flower Availability",y="Average Number of Visits") 
```

##Intensity as a function of resources

```{r}
mobs<-obsf[,] %>% group_by(Bird,Plant,Month,Transect_R) %>% summarize(Events=n(),d=mean(Yobs),Traitmatch=unique(Traitmatch),Flowers=mean(Flowers))

#merge with names
mobss<-merge(mobs,pindex,by.x="Plant",by.y="Index")
colnames(mobss)<-c("Plant","Species","Month","Transect_R","Events","d","Traitmatch","Flowers","Iplant_Double")

ggplot(mobss,aes(x=log(Flowers),y=d,col=Traitmatch)) + geom_point(aes(size=Events),alpha=.8) + theme_bw() + facet_wrap(~Species,scales="free") + scale_color_continuous(low="blue",high="red") + labs(y="Average Number of Visits")
```


##Intensity as a function of elevation range

```{r}
mobs<-obsf[,] %>% group_by(Bird,Plant) %>% summarize(Events=n(),d=mean(Yobs),Traitmatch=unique(Traitmatch),ElevD=unique(ElevD))

#merge with names
mobss<-merge(mobs,pindex,by.x="Plant",by.y="Index")
colnames(mobss)<-c("Plant","Species","Events","d","Traitmatch","ElevD","Iplant_Double")

ggplot(mobss,aes(x=ElevD,y=d,col=Traitmatch)) + geom_point(aes(size=Events),alpha=.8) + theme_bw() + facet_wrap(~Species,scales="free") + scale_color_continuous(low="blue",high="red") + ylab("Average Number of Visits") + geom_text(data=mobss[mobss$ElevD>500,],aes(label=Iplant_Double)) 
+ ggtitle("Elevation Ranges")

ggplot(obsf,aes(x=ElevD,y=(Yobs>0)*1,col=Traitmatch)) + geom_point(alpha=.8) + theme_bw() + facet_wrap(~Bird,scales="free") + scale_color_continuous(low="blue",high="red")  + ylab("Number of Visits") + xlim(0,1000) + geom_smooth(method="glm",family="binomial")

```

##Mixed Effect models with non-detections
Poisson Counts
```{r}
#Trait only
traitonly<-glmer(data=obsf,Yobs~Traitmatch + (1|Bird),family="poisson")

#Traits and resources
trait_resource<-glmer(data=obsf,Yobs~Traitmatch + scale(Flowers) + (1|Bird) + (1|Plant),family="poisson")

#Interaction of trait and resources
tr_interactionF<-glmer(data=obsf,Yobs~Traitmatch * scale(Flowers) + (1|Bird) + (1|Plant),family="poisson")

#Interaction of trait and resources as a binary variable
tr_interactionA<-glmer(data=obsf,Yobs~Traitmatch * Availability + (1|Bird),family="poisson")

#Interaction of trait and resources as a binary variable
tr_interactionA<-glmer(data=obsf,Yobs~Traitmatch * Availability + (1|Bird) ,family="poisson")

#Full model
full<-glmer(data=obsf,Yobs~scale(ElevD) + Traitmatch * scale(Flowers) + (1|Bird) + (1|Plant),family="poisson")

anova(traitonly,trait_resource,tr_interactionF,tr_interactionA)
summary(tr_interactionA)
```

##Hierarchical Bayesian Model


### Model Fitting

$$ Yobs_{i,j,k} \sim Binom(Detect_i,N_{i,j,k}) $$

$$ N_{i,j,k} \sim Pois(\lambda_{i,j,k}) $$

$$log(\lambda_{i,j,k})<-\alpha_i + \beta_i * abs(Bill_i - Corolla_j) * \beta_2 * Resources_k + \beta_3 * Resources_k * abs(Bill_i - Corolla_j) $$

**Priors**

$$ Detect \sim U(0,1) $$
$$\alpha_i \sim N(intercept,\tau_{\alpha})$$
$$\beta_{1,i} \sim N(\gamma_1i,\tau_{\beta_1})$$
$$\beta_{2,i} \sim N(\gamma_2i,\tau_{\beta_2})$$
$$\beta_{3,i} \sim N(\gamma_3i,\tau_{\beta_3})$$


**Hyperpriors**

Group Level Means

$$\gamma_{1,i} \sim N(0.001,0.001)$$
$$\gamma_{2,i} \sim N(0.001,0.001)$$
$$\gamma_{3,i} \sim N(0.001,0.001)$$
$$ intercept \sim N(0.001,0.001)$$

Group Level Variance

$$\tau_{\alpha} \sim Gamma(0.001,0.001)$$
$$\tau_\beta1 \sim Gamma(0.001,0.001)$$
$$\tau_\beta2 \sim Gamma(0.001,0.001)$$
$$\tau_\beta3 \sim Gamma(0.001,0.001)$$

**Derived quantities**

$$\sigma_{int} = \frac{1}{\tau_{\alpha}}^2$$
$$\sigma_{slope1} = \frac{1}{\tau_{\beta_1}}^2$$
$$\sigma_{slope2} = \frac{1}{\tau_{\beta_2}}^2$$
$$\sigma_{slope3} = \frac{1}{\tau_{\beta_3}}^2$$


```{r,eval=T,strip.white=T}

#Source model
source("Bayesian/NmixturePoissonRagged.R")

#print model
writeLines(readLines("Bayesian/NmixturePoissonRagged.R"))

#Input Data
Dat <- list(
  #Observations
  Yobs=obsf$Yobs,
  Nobs=nrow(obsf),
  
  #indices
  Bird=obsf$Bird,
  Plant=obsf$Plant,
  Time=1:nrow(obsf),
  
  #Length of variables
  Birds=max(obsf$Bird),
  resources=obsf$Availability,
  traitmatch=obsf$Traitmatch)

#Inits
initB<-rep(.5,Dat$Birds)
#Ninit<-array(dim=c(Dat$Birds,Dat$Plants,Dat$Time),data=10)
Ninit<-rep(max(obsf$Yobs),Dat$Nobs)

InitStage <- function(){list(beta1=initB,beta2=initB,detect=initB,beta3=initB,alpha=initB,intercept=0,tau_alpha=0.1,tau_beta1=0.1,tau_beta2=0.1,tau_beta3=0.1,gamma1=0,gamma2=0,gamma3=0,N=Ninit)}

#Parameters to track
ParsStage <- c("alpha","beta1","beta2","beta3","intercept","sigma_int","sigma_slope1","sigma_slope2","sigma_slope3","gamma1","gamma2","gamma3","detect","fit","fitnew")

#MCMC options

ni <- 10000  # number of draws from the posterior
nt <- 25  #thinning rate
nb <- ni*.95 # number to discard for burn-in
nc <- 2  # number of chains

#Jags

m1 = jags(inits=InitStage,
         n.chains=nc,
         model.file="Bayesian/NmixturePoissonRagged.jags",
         working.directory=getwd(),
         data=Dat,
         parameters.to.save=ParsStage,
         n.thin=nt,
         n.iter=ni,
         n.burnin=nb,
         DIC=T)

#save model output
save(list="m1",file="Bayesian/SavedModels/NmixturePoissonRagged.RData")
```

```{r,eval=F}
#Bring in a model from file if needed
load(file="Bayesian/SavedModels/NmixturePoissonRagged.RData")
recompile(m1)
```

```{r,eval=T}
#format params
pars<-extract_par(m1)
```

###Assess Convergence

```{r,cache=FALSE,eval=TRUE,fig.height=5}
#Intercept
chainplot(pars,"detect","Detection Probabily")

###Species level Slopes
chainplot(pars,c("alpha","beta1","beta2","beta3"),"Species regression") + facet_grid(species~par)

chainplot(pars,c("gamma1","gamma2","gamma3","sigma_int","sigma_slope1","sigma_slope2","sigma_slope3"),"Group Level Regression") + facet_wrap(~par)
```


###Posteriors

```{r,cache=FALSE,fig.width=12,fig.height=8}

#intercept
tracegplot(pars,"detect","Detection Parameters") + xlim(0,1) + facet_wrap(~species)

###Slope Posterior Distributions
tracegplot(pars,c("alpha","beta1","beta2","beta3"),"Detection Parameters") + facet_grid(species~par)

###Detection Posterior Distributions
tracegplot(pars,c("gamma1","gamma2","gamma3","sigma_int","sigma_slope1","sigma_slope2","sigma_slope3"),"Group-level Parameters") + facet_wrap(~par,nrow=2)
```

###Predicted Relationship 

```{r,fig.height=4,fig.width=4}
#Expand out pars
castdf<-dcast(pars[pars$par %in% c("gamma1","gamma2","gamma3","intercept"),], Chain + Draw~par,value.var="estimate")
```

```{r}
#Trajectories from posterior
predy<-trajF(alpha=castdf$intercept,beta1=castdf$gamma1,x=Dat$traitmatch,resources=Dat$resources,beta2=castdf$gamma2,beta3=castdf$gamma3)

psim3<-ggplot(data=predy,aes(x=x)) + geom_ribbon(aes(ymin=lower,ymax=upper),alpha=0.1,fill="red")  + geom_line(aes(y=mean),size=.8,col="red",linetype="dashed") + theme_bw() + ylab("Interactions") + xlab("Difference between Bill and Corolla Length") + geom_point(data=obsf,aes(x=Traitmatch,y=Yobs))
psim3

```

###Visualize interactions

```{r}
predyint<-intF(alpha=castdf$intercept,beta1=castdf$gamma1,x=Dat$traitmatch,resources=Dat$resources,beta2=castdf$gamma2,beta3=castdf$gamma3)

psim4<-ggplot(data=predyint,aes(x=x)) + geom_ribbon(aes(ymin=lower,ymax=upper),alpha=0.3,fill="black") + theme_bw() + ylab("Effect of Resources on Trait Matching") + geom_line(aes(y=mean),size=.8,col="black",linetype="dashed") + xlab("Difference between Bill and Corolla Length") 

psim4
```

###Species Predictions

```{r}
#orignal data to plot as ppints
odat<-merge(obsf,bindex,by.x="Bird",by.y="Index")
odat<-merge(odat,pindex,by.x="Plant",by.y="Index")
```

```{r,fig.height=10,fig.width=11,eval=T}

castdf<-dcast(pars[pars$par %in% c("beta1","beta2","beta3","alpha"),], species +Chain +Draw ~par ,value.var="estimate")

#Turn to 
castdf$species<-factor(castdf$species,levels=1:max(as.numeric(castdf$species)))

species.split<-split(castdf,list(castdf$species),drop = T)

species.traj<-list()

for(d in 1:length(species.split)){
  x<-species.split[[d]]
  index<-unique(x$species)
  
  #get data for those species
  billd<-obsf[obsf$Bird %in% index,]
  
  species.traj[[d]]<-trajF(alpha=x$alpha,beta1=x$beta1,beta2=x$beta2,beta3=x$beta3,resources=billd$Availability,x=billd$Traitmatch)
  }

names(species.traj)<-names(species.split)

species.traj<-melt(species.traj,id.var=colnames(species.traj[[1]]))

#split out names and model
species.traj[,c("Index")]<-colsplit(species.traj$L1,"\\.",c("Index"))

spe<-merge(species.traj,bindex,by.x="Index",by.y="Index")


#match colnames
colnames(odat)[12:13]<-c("Species","Iplant_Double")

#plot and compare to original data
ggplot(data=spe,aes(x=x)) + geom_ribbon(aes(ymin=lower,ymax=upper),alpha=0.1) + geom_line(aes(y=mean),size=1) + theme_bw() + ylab("Occurrence Probability")+ xlab("Difference between Bill and Corolla Length") + facet_wrap(~Species,scales="free",ncol=3) + geom_point(data=odat,aes(x=Traitmatch,y=Yobs))
```

###Species Level Interaction

```{r,fig.height=10,fig.width=13,eval=T}

castdf<-dcast(pars[pars$par %in% c("beta1","beta2","beta3","alpha"),], species +Chain + Draw~par,value.var="estimate")

#Turn to 
castdf$species<-factor(castdf$species,levels=1:max(as.numeric(castdf$species)))

species.split<-split(castdf,list(castdf$species),drop = T)

species.traj<-list()

for(d in 1:length(species.split)){
  dat<-species.split[[d]]
  index<-unique(dat$species)
  
  #get data for those species
  billd<-obsf[obsf$Bird %in% index,]
  
  #Calculate interaction effect
  species.traj[[d]]<-intF(alpha=dat$alpha,beta1=dat$beta1,x=billd$Traitmatch,resources=billd$Availability,beta2=dat$beta2,beta3=dat$beta3)
  
  }

names(species.traj)<-names(species.split)

species.traj<-melt(species.traj,id.var=colnames(species.traj[[1]]))

#split out names and model
species.traj[,c("Index")]<-colsplit(species.traj$L1,"\\.",c("Index"))

spe<-merge(species.traj,bindex,by.x="Index",by.y="Index")


#match colnames
colnames(odat)[12:13]<-c("Species","Iplant_Double")

#plot and compare to original data
ggplot(data=spe,aes(x=x)) + geom_ribbon(aes(ymin=lower,ymax=upper,fill=Species),alpha=0.1) + geom_line(aes(y=mean,col=Species),size=1) + theme_bw() + xlab("Difference between Bill and Corolla Length")  + ylab("Effect of Resources on Trait Matching") + facet_wrap(~Species,scales="free")
```


###Posterior Check

```{r,fig.height=4,fig.width=8,eval=T}

fitstat<-droplevels(pars[pars$par %in% c("fit","fitnew"),])
fitstat<-dcast(fitstat,Draw+Chain~par,value.var="estimate")

#add 1:1 line
ymin<-round(min(c(fitstat$fit,fitstat$fitnew)))
ymax<-round(max(c(fitstat$fit,fitstat$fitnew)))
ab<-data.frame(x=ymin:ymax,y=ymin:ymax)

p<-ggplot(fitstat,aes(x=fit,y=fitnew)) + geom_point() + theme_bw() + coord_equal()
psim5<-p  + labs(x="Discrepancy of observed data",y="Discrepancy of replicated data",col="Model") + geom_line(data=ab,aes(x=x,y=y)) + ggtitle("Simulated Data")

psim5
```


```{r}
save.image("Observed.RData")
```
