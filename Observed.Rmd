---
title: Niche overlap increases with increasing resource availability in a tropical
  plant-pollinator network.
author: "Ben Weinstein"
date: "Tuesday, October 14, 2014"
output:
  html_document:
    toc: true
    theme: spacelab
  word_document: default
  keep_md: true
---

#Aim
Which birds use which plants? What are the mechanisms that determine niche overlap in this assemblage.

We will fit several difference types of models and ask how they inform our understanding. For each model, we try to calculate a measure of discrepancy and assess model fit.

##Data

* Using automated cameras and transects, we have been recording flower visitation rates by each hummingbird species for two years.
* We have bill and corolla lengths for each species of bird and flower.
* We have been collecting phenology data on available resources

Birds use flowers that have similar length of bill shape and we expect the importance of trait matching to decrease as available resources increase.

```{r,echo=FALSE,warning=FALSE,message=FALSE}
library(knitr)
library(R2jags)
library(reshape2)
library(ggplot2)
library(scales)
library(dplyr)
library(stringr)
library(lme4)
library(picante)
library(igraph)
library(bipartite)
library(effects)
library(chron)
library(gridExtra)
library(MASS)
library(boot)
library(BEST)
library(GGally)
#Set Dropbox Location
#setwd to dropbox
droppath<-"C:/Users/Ben/Dropbox/"

#Set github path
gitpath<-"C:/Users/Ben/Documents/NetworkTime/"

setwd(gitpath)

opts_chunk$set(message=FALSE,warning=FALSE,fig.height=9,fig.width=13,echo=FALSE,cache=F, fig.path='figure/')

#source bayes functions
source("Bayesian/BayesFunctions.R")
```

```{r,eval=T}
#load data is needed
#load("Observed.RData")
```

#Read in Data
```{r}
#read in flower morphology data, comes from Nectar.R
droppath<-"C:/Users/Ben/Dropbox/"
fl.morph<-read.csv(paste(droppath,"Thesis/Maquipucuna_SantaLucia/Results/FlowerMorphology.csv",sep=""))

#First row is empty
fl.morph<-fl.morph[-1,]

#Bring in Hummingbird Morphology Dataset, comes from
hum.morph<-read.csv(paste(droppath,"Thesis/Maquipucuna_SantaLucia/Results/HummingbirdMorphology.csv",sep=""))

#Bring in Interaction Matrix
int<-read.csv(paste(droppath,"Thesis/Maquipucuna_SantaLucia/Results/Network/HummingbirdInteractions.csv",sep=""),row.names=1)

#Correct known taxonomic errors
int[int$Iplant_Double=="Alloplectus purpureus","Iplant_Double"]<-"Glossoloma purpureum"
int[int$Iplant_Double=="Capanea affinis","Iplant_Double"]<-"Kohleria affinis"
int[int$Iplant_Double=="Columnea cinerea","Iplant_Double"]<-"Columnea mastersonii"
int[int$Iplant_Double=="Alloplectus teuscheri","Iplant_Double"]<-"Drymonia teuscheri"

#remove species with less than  20 observations
keep<-names(which(table(int$Hummingbird) > 30))

int<-droplevels(int[int$Hummingbird %in% keep,])

m.dat<-droplevels(int[colnames(int) %in% c("ID","Video","Time","Hummingbird","Sex","TransectID","Transect_R","Iplant_Double","Pierce","DateP","Month","ele","Type")])

#Does the data come from camera or transect?
m.dat$Type<-(is.na(m.dat$TransectID))*1

#m.dat<-m.dat[m.dat$Type==1,]

m.dat$Year<-years(as.Date(m.dat$DateP))
#one missing date
m.dat$Year[m.dat$Year %in% 2012]<-2013

#Fix spacing to match clades
#Which are matching
levels(m.dat$Hummingbird)[!levels(m.dat$Hummingbird) %in% hum.morph$English]

#Number of bird species
h_species<-nlevels(m.dat$Hummingbird)

#Number of plant species
plant_species<-nlevels(m.dat$Iplant_Double)

#Get english name
dath<-merge(m.dat,hum.morph, by.x="Hummingbird",by.y="English",keep=all)

#Merge to flowers
int.FLlevels<-levels(factor(dath$Iplant_Double))

#Which flowers are we missing info for?
missingTraits<-int.FLlevels[!int.FLlevels %in% fl.morph$X]

print(paste("Missing Trait Information:",missingTraits))
dath<-merge(dath,fl.morph, by.x="Iplant_Double",by.y="X")

#Drop piercing events, since they don't represent correlation
dath<-dath[!dath$Pierce %in% c("y","Y"),]
```

##Match Species to Morphology

```{r}
#observed traitmatching
traitmatchF<-abs(t(sapply(hum.morph$Bill,function(x){x-fl.morph$TotalCorolla})))

rownames(traitmatchF)<-hum.morph$English
colnames(traitmatchF)<-fl.morph$Group.1
```

```{r}
#match names
#Round to 2 decimals
#Convert to cm for winbugs, avoids numerical underflow
traitmatchT<-round(traitmatchF[rownames(traitmatchF) %in% dath$Hummingbird,colnames(traitmatchF) %in% dath$Iplant_Double],2)/10

traitmatchT<-traitmatchT[sort(rownames(traitmatchT)),sort(colnames(traitmatchT))]

```

###Elevation ranges

Create a binary variable whether each observation was in a low elevation or high elevation transect. We have some species that just occur at the top of the gradient, and are not present in the sampling window of flowers at the low elevation.

Accounting for non-availability.
We have to figure out which plants were sampled in which periods, and if it was sampled, the non-detection are 0 if it wasn't the non-detection are NA. then remove all the Na's.

```{r}
elevH<-read.csv("InputData/HummingbirdElevation.csv",row.names=1)
head(elevH)
colnames(elevH)[5]<-"Elevation"
elevH$Bird<-1:nrow(elevH)

#high elevation or low elevation
elevP<-read.csv("InputData/PlantElevation.csv",row.names=1)
colnames(elevP)[5]<-"Elevation"
elevP$Plant<-1:nrow(elevP)
elevP$Iplant_Double<-as.character(elevP$Iplant_Double)

#Correct known taxonomic errors
elevP[elevP$Iplant_Double %in% "Alloplectus purpureus","Iplant_Double"]<-"Glossoloma purpureum"
elevP[elevP$Iplant_Double %in% "Capanea affinis","Iplant_Double"]<-"Kohleria affinis"
elevP[elevP$Iplant_Double %in% "Alloplectus teuscheri","Iplant_Double"]<-"Drymonia teuscheri"
elevP[elevP$Iplant_Double %in% "Columnea cinerea","Iplant_Double"]<-"Columnea mastersonii"
elevP[elevP$Iplant_Double %in% "Alloplectus tenuis","Iplant_Double"]<-"Drymonia tenuis"

#Merge to observed Data
#plants
dathp<-merge(dath,elevP,by="Iplant_Double")

#birds
datph<-merge(dathp,elevH,by="Hummingbird")

```

#Available Resources

```{r}
#read in flower totals from FlowerTransects.R
fl<-read.csv(paste(droppath,"Thesis/Maquipucuna_SantaLucia/Results/FlowerTransects/FlowerTransectClean.csv",sep=""))

#select desired columns
fltransects<-fl %>% dplyr::select(Iplant_Double,month,Year,ID,Transect.ID,Family,Genus,Species,Height,Total_Flowers,Transect_R,Date,lon,lat,ele)

#dates need a bit of formatting
fltransects$DateP<-as.POSIXlt(fltransects$Date,format="%d/%m/%y")

#which are NA needs to date/month reversed. ugly.
fltransects[which(is.na(fltransects$DateP)),"DateP"]<-as.character(as.POSIXlt(as.character(fltransects[which(is.na(fltransects$DateP)),"Date"]),format="%m/%d/%Y"))

#remove withour elevation records (less than 1% of data)
fltransects<-fltransects[!is.na(fltransects$ele),]

#month should be capital 
colnames(fltransects)[colnames(fltransects) %in% "month"]<-"Month"

#Count of flowers per month
fltransects$DateP<-as.character(fltransects$DateP)
flower.month<-group_by(fltransects,Month,Year,Transect_R,DateP) %>% dplyr::summarise(Flowers=sum(Total_Flowers,na.rm=TRUE))  %>% filter(Flowers>20)
  
#Make month abbreviation column, with the right order
flower.month$Month.a<-factor(month.abb[flower.month$Month],month.abb[c(1:12)])

#Make year factor column
flower.month$Year<-as.factor(flower.month$Year)

#get quantile for each transect
thresh<-melt(group_by(flower.month,Transect_R) %>% summarize(Threshold=quantile(log(Flowers),0.5)) )
flower.month<-merge(flower.month,thresh)
flower.month$Availability<-as.factor((log(flower.month$Flowers)>flower.month$value) * 1)

#plot
ggplot(flower.month,aes(x=Month.a,log(Flowers),shape=as.factor(Year),col=Availability)) + geom_point(size=3) + theme_bw()  + geom_smooth(aes(group=1)) + ylab("Flowers") + xlab("Month") + facet_wrap(~Transect_R,scales="free_y") + labs(shape="Year", y= "Log Available Flowers") + scale_x_discrete(breaks=month.abb[seq(1,12,2)]) + scale_color_manual(labels=c("Low","High"),values=c("black","red")) + labs(col="Resource Availability")

#turn min and max eelvation into seperate columns for the range
flower.month$minElev<-as.numeric(str_extract(flower.month$Transect_R,"(\\d+)"))
flower.month$maxElev<-as.numeric(str_match(flower.month$Transect_R,"(\\d+)_(\\d+)")[,3])
```

What is the temporal distribution of resources?

```{r,fig.height=5,fig.width=5}
#moment 
moment<-fitdistr(flower.month$Flowers,"log-normal")

est<-data.frame(x=seq(0,max(flower.month$Flowers),100),Flowers=dlnorm(x=seq(0,max(flower.month$Flowers),100),meanlog=moment$estimate[1],sdlog=moment$estimate[2]))
ggplot(flower.month,aes(x=Flowers)) + geom_density(fill="black") + geom_line(data=est,aes(x=x,y=Flowers),col='red') + theme_bw() + labs(x="Total Monthly Available Resources",y="Density") + ggtitle("Resources are exponentially distributed over time")
```

Appears to be a log normal distribution with the existance of rare, but intense, pulses.

### Summarize Observations

```{r}
#ID for NA is holger transects, make the id's 1:n for each day of transect at each elevation, assuming no elevation was split across days.
datph$ID<-as.character(datph$ID)

noid<-datph[is.na(datph$ID),]

id_topaste<-paste(noid$Transect_R,noid$DateP,"Transect",sep="_")
datph[which(is.na(datph$ID)),"ID"]<-id_topaste
  
indatraw<- datph %>% group_by(Bird,Plant,ID,DateP) %>% summarize(Yobs=n(),Elev=mean(ele,na.rm=T),Transect_R=unique(Transect_R)) 

indatraw[order(indatraw$Yobs,decreasing=T),]
#add unique ID
indatraw$Time<-1:nrow(indatraw)

#add months and years
indatraw$Month<-as.numeric(factor(months(strptime(indatraw$DateP,format="%Y-%m-%d")),levels=month.name))
indatraw$Year<-years(indatraw$DateP)

#Species names
for (x in 1:nrow(indatraw)){
  indatraw$Hummingbird[x]<-as.character(elevH[elevH$Bird %in% indatraw$Bird[x],"Hummingbird"])
  indatraw$Iplant_Double[x]<-as.character(elevP[elevP$Plant %in% indatraw$Plant[x],"Iplant_Double"])
}
```

What elevation transect is each observation in?
The camera data need to be inferred from the GPS point.

```{r}
#which elevation bin is each observation within
labs<-paste(seq(1300,2500,200),seq(1500,2700,200),sep="_")
indatraw[is.na(indatraw$Transect_R),"Transect_R"]<-cut(indatraw[is.na(indatraw$Transect_R),]$Elev,seq(1300,2700,200),labels=labs)
```

```{r}
#match the traits
traitmelt<-melt(traitmatchT)
colnames(traitmelt)<-c("Hummingbird","Iplant_Double","Traitmatch")

indatraw<-merge(indatraw,traitmelt,by=c("Hummingbird","Iplant_Double"))
```

#Choosing a response distribution

Before we account for elevation and availability, what is the distribution of intensity of interactions?

```{r}
ggplot(indatraw,aes(x=Yobs)) + geom_histogram()
```

If we tend to think of the intensity of events as poisson, our data is extremely ones-inflated. The first moment of the poisson does not well capture the data.

The best fitting moment is in opaque red. The observed data is in black.

```{r,fig.width=5,fig.height=5}
moment<-fitdistr(indatraw$Yobs,"poisson")
est<-data.frame(Yobs=rpois(n=length(indatraw$Yobs),lambda=moment$estimate[[1]]))
ggplot(indatraw,aes(x=Yobs)) + geom_histogram(fill="black") + geom_histogram(data=est,fill="red",alpha=.4) + theme_bw() + ggtitle("Poisson intensity of interactions")
```

What about negative binomial?

The best fitting moment is in opaque red. The observed data is in black.

```{r,fig.width=5,fig.height=5}
moment<-fitdistr(indatraw$Yobs,"negative binomial")
est<-data.frame(Yobs=rpois(n=length(indatraw$Yobs),lambda=moment$estimate[[1]]))
ggplot(indatraw,aes(x=Yobs)) + geom_histogram(fill="black") + geom_histogram(data=est,fill="red",alpha=.4) + theme_bw()
```

What about log normal?

```{r,fig.width=5,fig.height=5}
moment<-fitdistr(indatraw$Yobs,"lognormal")
est<-data.frame(Yobs=rpois(n=length(indatraw$Yobs),lambda=moment$estimate[[1]]))
ggplot(indatraw,aes(x=Yobs)) + geom_histogram(fill="black") + geom_histogram(data=est,fill="red",alpha=.4) + theme_bw()
```

The best fitting moment is in opaque red. The observed data is in black.

#Absences - accounting for non-detection

```{r}
#expand out data
indatlong<-acast(indatraw,Bird~Plant~Time,value.var="Yobs")
indatlong[is.na(indatlong)]<-0
```

We have more information than just the presences, given species elevation ranges, we have absences as well. Absences are birds that occur at the elevation of the plant sample, but were not recorded feeding on the flower.

```{r}
#Only non-detections are real 0's, the rest are NA's and are removed.
#Plants not surveyed in that time period
#Hummingbirds not present at that site

for(x in 1:dim(indatlong)[3]){
  #Remove non sampled plants 
  a<-indatlong[,,x]
  
  #No observations at that plant
  toNA<-as.numeric(names(which(apply(a,2,sum)==0)))
  pres<-as.numeric(names(which(!apply(a,2,sum)==0)))
  indatlong[,colnames(a) %in% toNA,x]<-NA
  
  #match elevation if there were presences, slightly terse code.
  if(length(pres)>0){
    for (y in 1:length(pres)){
      #Plant range
      pr<-elevP[elevP$Plant %in% pres[y],"Elevation"]
      #if there is not enough elevation area, make NA
      if(is.na(pr)|!pr==3){
        helim<-elevH[!elevH$Elevation %in% c(pr,3),"Bird"]
        #sanity check, make sure rows don't have values
        sums<-indatlong[rownames(a) %in% helim,colnames(a) %in% pres[y],x]==0
        helim<-helim[sums]
        
        #set to NA if they are outside of elevation and are blank
        indatlong[rownames(a) %in% helim ,colnames(a) %in% pres[y],x]<-NA
        }
      }  
    }
  }

#melt and remove Na's
indat<-melt(indatlong)
indat<-indat[!is.na(indat$value),]

colnames(indat)<-c("Bird","Plant","Time","Yobs")
```

Remerge data with predictors

```{r}
#remerge the time period data
Timelookup<-indatraw %>% dplyr::select(Time,DateP,Transect_R,Month,Year)%>% group_by(Time,DateP,Transect_R,Month,Year) %>% distinct() %>% arrange(Time)

#Get time information
obsf<-merge(indat,Timelookup[,!colnames(Timelookup) %in% c("Bird","Plant")],by=c("Time"),all.x=T)

#Species names
for (x in 1:nrow(obsf)){
  obsf$Hummingbird[x]<-as.character(elevH[elevH$Bird %in% obsf$Bird[x],"Hummingbird"])
  obsf$Iplant_Double[x]<-as.character(elevP[elevP$Plant %in% obsf$Plant[x],"Iplant_Double"])
}

#Get trait information
#match the traits
obsf<-merge(obsf,traitmelt,by=c("Hummingbird","Iplant_Double"))
```

##Resource availability at each data point

Three measures of resources.

* All Resources within two weeks at that elevation transect (200m)
* All resource used by the hummingbird species within two weeks at that elevation transect (200m)
* The abundance of the particular flower species within two weeks at that elevation transect (200m)

```{r}
#merge with original data, easier to do as factors
obsf<-as.data.frame(obsf)
obsf$Time<-as.factor(obsf$Time)

#Date class
obsf$DateP<-as.Date(obsf$DateP)
fltransects$DateP<-as.Date(fltransects$DateP)
#set column to NA
obsf$All_Flowers<-NA
obsf$Used_Flowers<-NA
obsf$FlowerA<-NA

#Resource list for each species.
slist<-int %>% group_by(Hummingbird,Iplant_Double) %>% distinct() %>% dplyr::select(Hummingbird,Iplant_Double) %>% arrange(Hummingbird)

for (x in 1:nrow(obsf)){
 event_date<-obsf[x,"DateP"] 
 event_transect<-obsf[x,"Transect_R"]
 
 #Flowers used by the species
 sp_list<-slist[slist$Hummingbird %in% obsf$Hummingbird[x],"Iplant_Double"]
  
 #Species of flower
 sp <-  obsf[x,"Iplant_Double"]

 #filter by elevation
 #get the above and below transect
 tr<-as.numeric(as.factor(event_transect))
 toselect<-levels(event_transect)[c(tr-1,tr,tr+1)]
 #remove na's
 toselect<-toselect[!is.na(toselect)]
 byelev<-fltransects[fltransects$Transect_R %in% toselect,]
 
 #Filter by Date
 bydate<-byelev[abs(byelev$DateP -event_date)  < 30,]
 
 #average number of flowers at each elevation within that time frame.
 
 #count number of all flowers
 obsf$All_Flowers[x]<- bydate%>% group_by(DateP,Transect_R) %>% summarize(n=sum(Total_Flowers,na.rm=T)) %>% group_by(Transect_R) %>% summarize(mn=mean(n)) %>% summarize(F=sum(mn)) %>% .$F
 
 #filter by species
  byspecies<-bydate[bydate$Iplant_Double %in% sp_list$Iplant_Double,]
 
  obsf$Used_Flowers[x]<-byspecies%>% group_by(DateP,Transect_R) %>% summarize(n=sum(Total_Flowers,na.rm=T)) %>% group_by(Transect_R) %>% summarize(mn=mean(n)) %>% summarize(F=sum(mn)) %>% .$F
  
  #just the abundance of that species
  bys <-  byspecies[byspecies$Iplant_Double %in% sp,]
  obsf$FlowerA[x] <-  bys %>% group_by(DateP,Transect_R) %>% summarize(n=sum(Total_Flowers,na.rm=T)) %>% group_by(Transect_R) %>% summarize(mn=mean(n)) %>% summarize(F=sum(mn)) %>% .$F

}
```

Give binary versions of these resources as well - what matters is if its high or low for that resource measure. This helps account for the enormously long tail of resource pulses and minimizes the noise associated with such a widely ranging variable. The points on the huge blooms are going to have large leverage.

View quantile thresholds (0.5,.75,.9) as vertical lines.

```{r}
mf<-melt(obsf,measure.vars=c("All_Flowers","Used_Flowers","FlowerA"))
ggplot(mf,aes(x=value,fill=variable)) + geom_density() + facet_wrap(~variable,scales='free',ncol=1) + geom_vline(aes(xintercept=quantile(value,c(0.5,.75,.9))),size=1,alpha=.3)
```

```{r}
obsf$BAll_Flowers<-(obsf$All_Flowers > quantile(obsf$All_Flowers,0.75))*1
```

```{r}
sob<-split(obsf,obsf$Hummingbird)
for(x in 1:length(sob)){
  sob[[x]]$BUsed_Flowers<-( sob[[x]]$Used_Flowers > quantile( sob[[x]]$Used_Flowers,0.75))*1
}
obsf<-rbind_all(sob)

#visualize
ggplot(obsf[obsf$BUsed_Flowers==0,],aes(x=Used_Flowers,fill=Hummingbird)) + geom_density() + facet_wrap(~Hummingbird,scales='free')
```

```{r}
sob<-split(obsf,obsf$Hummingbird)
for(x in 1:length(sob)){
  sob[[x]]$BFlowerA<-( sob[[x]]$FlowerA > quantile( sob[[x]]$FlowerA,0.75))*1
}
obsf<-as.data.frame(rbind_all(sob))

#visualize
ggplot(obsf[obsf$BFlowerA==0,],aes(x=FlowerA,fill=Hummingbird)) + geom_density() + facet_wrap(~Hummingbird,scales='free')
```

Given that these resource values are very large, scale by dividing by sd and subtracting the mean. Mean =0, sd=1. For used resources, this needs to be scaled per species

```{r}
obsf$All_Flowers<-as.numeric(scale(obsf$All_Flowers))

obsf$FlowerA<-as.numeric(scale((obsf$FlowerA)))
```


Relationship among resource measures

```{r}
ggplot(obsf,aes(x=All_Flowers,y=Used_Flowers,col=log(FlowerA))) + geom_point()
```

##Exploratory model fitting

Let's look at the same figures as above, with the addition of informed 0's for non-detections.

##Mean Intensity as a function of traits
```{r}
mobs<-obsf[,] %>% group_by(Hummingbird,Iplant_Double,Month,Year) %>% summarize(Events=n(),d=mean(Yobs),Traitmatch=unique(Traitmatch),Used_Flowers=mean(Used_Flowers))

ggplot(mobs,aes(x=Traitmatch,y=d,col=Used_Flowers)) + geom_point(aes(size=Events),alpha=.8)  + scale_size_continuous(range=c(2,6)) + labs(col="Flower Availability",y="Average Number of Visits") + scale_color_continuous(low='blue',high='red') + facet_wrap(~Hummingbird,ncol=2) + theme_bw()
```

##Mean Intensity as a function of resources

```{r}
mobs<-obsf[,] %>% group_by(Hummingbird,Iplant_Double,Month) %>% summarize(Events=n(),d=mean(Yobs),Traitmatch=unique(Traitmatch),Flowers=mean(Used_Flowers))

ggplot(mobs,aes(x=log(Flowers),y=d,col=Traitmatch)) + geom_point(aes(size=Events),alpha=.8) + theme_bw() + facet_wrap(~Hummingbird,scales="free") + scale_color_continuous(low="blue",high="red") + labs(y="Average Number of Visits")
```

##Mixed Effect models

For initial inference, let's look at some reasonable mixed effect models. There is no zero inflation here, so we treat these data with some caution.

```{r}
#Trait only
traitonly<-glmer(data=obsf,Yobs~Traitmatch + (1|Bird),family="poisson")
summary(traitonly)

#Traits and resources
trait_resource<-glmer(data=obsf,Yobs~Traitmatch + BUsed_Flowers + (1|Bird),family="poisson")

#Interaction of trait and resources 
tr_interactionA<-glmer(data=obsf,Yobs~Traitmatch * BAll_Flowers + (1|Bird),family="poisson")

tr_interactionU<-glmer(data=obsf,Yobs~Traitmatch * BUsed_Flowers + (1|Bird),family="poisson")

tr_interactionF<-glmer(data=obsf,Yobs~Traitmatch * BFlowerA + (1|Bird),family="poisson")

summary(tr_interactionA)
summary(tr_interactionU)
summary(tr_interactionF)
anova(tr_interactionA,tr_interactionU,tr_interactionF)
#Binary models
```

### Log tranformed presence only records
```{r}
tr_interactionFL<-lmer(data=obsf[obsf$Yobs>0,],log(Yobs)~Traitmatch * FlowerA + (1|Bird))
summary(tr_interactionF)
```

##Hierarchical Bayesian Model

### Model Fitting

$$ Yobs_{i,j,k} \sim Binom(Detect_i,N_{i,j,k}) $$

$$ N_{i,j,k} \sim Pois(\lambda_{i,j,k}) $$

$$log(\lambda_{i,j,k})<-\alpha_i + \beta_i * abs(Bill_i - Corolla_j) * \beta_2 * Resources_k + \beta_3 * Resources_k * abs(Bill_i - Corolla_j) $$

**Priors**

$$ Detect \sim U(0,1) $$
$$\alpha_i \sim N(intercept,\tau_{\alpha})$$
$$\beta_{1,i} \sim N(\gamma_1i,\tau_{\beta_1})$$
$$\beta_{2,i} \sim N(\gamma_2i,\tau_{\beta_2})$$
$$\beta_{3,i} \sim N(\gamma_3i,\tau_{\beta_3})$$

**Hyperpriors**

Group Level Means

$$\gamma_{1,i} \sim N(0,0.0001)$$
$$\gamma_{2,i} \sim N(0,0.0001)$$
$$\gamma_{3,i} \sim N(0,0.0001)$$
$$ intercept \sim N(0,0.0001)$$

Group Level Variance

$$\tau_{\alpha} \sim Gamma(0.0001,0.0001)$$
$$\tau_\beta1 \sim Gamma(0.0001,0.0001)$$
$$\tau_\beta2 \sim Gamma(0.0001,0.0001)$$
$$\tau_\beta3 \sim Gamma(0.0001,0.0001)$$

**Derived quantities**

$$\sigma_{int} = \frac{1}{\tau_{\alpha}}^2$$
$$\sigma_{slope1} = \frac{1}{\tau_{\beta_1}}^2$$
$$\sigma_{slope2} = \frac{1}{\tau_{\beta_2}}^2$$
$$\sigma_{slope3} = \frac{1}{\tau_{\beta_3}}^2$$

Reformat index for jags.
Jags needs a vector of input species 1:n with no breaks.

```{r}
obsf$Hummingbird<-as.factor(obsf$Hummingbird)
obsf$Iplant_Double<-as.factor(obsf$Iplant_Double)
obsf$jBird<-as.numeric(obsf$Hummingbird)
obsf$jPlant<-as.numeric(obsf$Iplant_Double)

jagsIndexBird<-data.frame(Hummingbird=levels(obsf$Hummingbird),jBird=1:length(levels(obsf$Hummingbird)))
 
jagsIndexPlants<-data.frame(Iplant_Double=levels(obsf$Iplant_Double),jPlant=1:length(levels(obsf$Iplant_Double)))
```

```{r,eval=T,strip.white=T,eval=T}

#Source model
source("Bayesian/NmixturePoissonRagged.R")

#print model
writeLines(readLines("Bayesian/NmixturePoissonRagged.R"))

#Input Data
Dat <- list(
  #Observations
  Yobs=obsf$Yobs,
  Nobs=nrow(obsf),
  
  #indices
  Bird=obsf$jBird,
  Plant=obsf$jPlant,
  Time=1:nrow(obsf),
  
  #Length of variables
  Birds=max(obsf$jBird),
  resources=obsf$BFlowerA,
  traitmatch=obsf$Traitmatch)

#Inits
initB<-rep(.5,Dat$Birds)
Ninit<-rep(max(Dat$Yobs)+1,Dat$Nobs)

InitStage <- function(){list(beta1=initB,beta2=initB,detect=initB,beta3=initB,alpha=initB,intercept=0,tau_alpha=0.1,tau_beta1=0.1,tau_beta2=0.1,tau_beta3=0.1,gamma1=0,gamma2=0,gamma3=0,N=Ninit)}

#Parameters to track
ParsStage <- c("alpha","beta1","beta2","beta3","intercept","sigma_int","sigma_slope1","sigma_slope2","sigma_slope3","gamma1","gamma2","gamma3","detect","fit","fitnew","E")

#MCMC options

ni <- 1000000  # number of draws from the posterior
nt <- 10  #thinning rate
nb <- ni*.96 # number to discard for burn-in
nc <- 2  # number of chains

```

```{r,eval=T}
#Jags
#if running the model for the first time
m1 = jags(inits=InitStage,
         n.chains=nc,
         model.file="Bayesian/NmixturePoissonRagged.jags",
         working.directory=getwd(),
         data=Dat,
         parameters.to.save=ParsStage,
         n.thin=nt,
         n.iter=ni,
         n.burnin=nb,
         DIC=T)

#save model output
```

Re-update if needed to extend

```{r,eval=F}
rjags::load.module('dic')
recompile(m1)
m1<-update(m1,n.iter=400000)
```

```{r,eval=T}
#format params
pars<-extract_par(m1)
```

###Assess Convergence

```{r,cache=FALSE,eval=TRUE,fig.height=5}
#Detect
chainplot(pars,"detect","Detection Probability")
```

```{r,fig.height=12}
###Species level Slopes
chainplot(pars,c("alpha","beta1","beta2","beta3","beta4"),"Species regression") + facet_grid(species~par)
```

```{r,fig.height=4}
chainplot(pars,c("gamma1","gamma2","gamma3","sigma_int","sigma_slope1","sigma_slope2","sigma_slope3"),"Group Level Regression") + facet_wrap(~par,nrow=1)
```

###Posteriors

```{r,cache=FALSE,fig.width=8,fig.height=10}
#intercept
tracegplot(pars,"detect","Detection Parameters") + xlim(0,1) + facet_wrap(~species,scales='free',ncol=2)
```

```{r,fig.height=12}
###Slope Posterior Distributions
tracegplot(pars,c("alpha","beta1","beta2","beta3"),"Species Level Parameters") + facet_grid(species~par,scale='free')
```

```{r,fig.height=5}
###Detection Posterior Distributions
tracegplot(pars,c("gamma1","gamma2","gamma3","sigma_int","sigma_slope1","sigma_slope2","sigma_slope3"),"Group-level Parameters") + facet_wrap(~par,nrow=2,scale='free')
```

###Predicted Relationship 

```{r,fig.height=4,fig.width=4}
#Expand out pars
castdf<-dcast(pars[pars$par %in% c("gamma1","gamma2","gamma3","intercept"),], Chain + Draw~par,value.var="estimate")
```

Hold resource relationship at 0, what does trait-matching look like?

```{r,fig.width=9,fig.height=7}
#Trajectories from posterior
predy<-trajF(alpha=castdf$intercept,beta1=castdf$gamma1,x=Dat$traitmatch,resources=Dat$resources,beta2=0,beta3=0,type='hdi')

ggplot(data=predy,aes(x=x)) + geom_ribbon(aes(ymin=lower,ymax=upper),alpha=0.1,fill="red")  + geom_line(aes(y=mean),size=.5,col="red",linetype="dashed") + theme_bw() + ylab("Interactions") + xlab("Difference between Bill and Corolla Length") + geom_point(data=obsf,aes(x=Traitmatch,y=Yobs))
```

Full posterior prediction

```{r,fig.width=9,fig.height=7}
#Trajectories from posterior
predy<-trajF(alpha=castdf$intercept,beta1=castdf$gamma1,x=Dat$traitmatch,resources=Dat$resources,beta2=castdf$gamma2,beta3=castdf$gamma3,type='hdi')

ggplot(data=predy,aes(x=x)) + geom_ribbon(aes(ymin=lower,ymax=upper),alpha=0.2,fill="red")  +  theme_bw() + ylab("Interactions") + xlab("Difference between Bill and Corolla Length") + geom_point(data=obsf,aes(x=Traitmatch,y=Yobs)) + geom_line(aes(y=mean))
```

Trait-matching at High and Low Resource Density

```{r}
#Trajectories from posterior
predH<-trajF(alpha=castdf$intercept,beta1=castdf$gamma1,x=obsf[obsf$BFlowerA==1,"Traitmatch"],resources=obsf[obsf$BFlowerA==1,"BFlowerA"],beta2=castdf$gamma2,beta3=castdf$gamma3,type='hdi')

predL<-trajF(alpha=castdf$intercept,beta1=castdf$gamma1,x=obsf[obsf$BFlowerA==0,"Traitmatch"],resources=obsf[obsf$BFlowerA==0,"BFlowerA"],beta2=castdf$gamma2,beta3=castdf$gamma3,type='hdi')

predhl<-melt(list(High=predH,Low=predL),id.vars=colnames(predH))

ggplot(data=predhl,aes(x=x)) + geom_ribbon(aes(ymin=lower,ymax=upper,fill=L1),alpha=0.2)  + geom_line(aes(y=mean,col=L1),size=.8) + theme_bw() + ylab("Interactions") + xlab("Difference between Bill and Corolla Length") + geom_point(data=obsf,aes(x=Traitmatch,y=Yobs))+ labs(fill="Resource Availability",col="Resource Availability") + facet_wrap(~L1,scales='free')
```

###Visualize interactions

```{r}
predyint<-intF(alpha=castdf$intercept,beta1=castdf$gamma1,x=Dat$traitmatch,resources=Dat$resources,beta2=castdf$gamma2,beta3=castdf$gamma3,type='hdi')

psim4<-ggplot(data=predyint,aes(x=x)) + geom_ribbon(aes(ymin=lower,ymax=upper),alpha=0.3,fill="black") + theme_bw() + ylab("Effect of Resources on Trait Matching") + geom_line(aes(y=mean),size=.8,col="black",linetype="dashed") + xlab("Difference between Bill and Corolla Length") 

psim4
```

###Species Predictions

```{r,fig.height=10,fig.width=11,eval=T}

castdf<-dcast(pars[pars$par %in% c("beta1","beta2","beta3","alpha"),], species +Chain +Draw ~par ,value.var="estimate")

#Turn to 
castdf$species<-factor(castdf$species,levels=1:max(as.numeric(castdf$species)))

species.split<-split(castdf,list(castdf$species),drop = T)

species.traj<-list()

for(d in 1:length(species.split)){
  x<-species.split[[d]]
  index<-unique(x$species)
  
  #get data for those species
  billd<-obsf[obsf$jBird %in% index,]

  #scale resources
  species.traj[[d]]<-trajF(alpha=x$alpha,beta1=x$beta1,beta2=x$beta2,beta3=x$beta3,resources=billd$BFlowerA,x=billd$Traitmatch,type='hdi')
  }

names(species.traj)<-names(species.split)

species.traj<-melt(species.traj,id.var=colnames(species.traj[[1]]))

#split out names and model
species.traj[,c("Index")]<-colsplit(species.traj$L1,"\\.",c("Index"))

spe<-merge(species.traj,jagsIndexBird,by.x="Index",by.y="jBird")

#plot and compare to original data
ggplot(data=spe,aes(x=x)) + geom_ribbon(aes(ymin=lower,ymax=upper),alpha=0.2,fill='red') + geom_line(aes(y=mean),size=.5) + theme_bw() + ylab("Occurrence Probability")+ xlab("Difference between Bill and Corolla Length") + facet_wrap(~Hummingbird,scales="free",ncol=3) + geom_point(data=obsf,aes(x=Traitmatch,y=Yobs),size=3)
```

###Species Level Interaction

```{r,fig.height=10,fig.width=13,eval=T}

castdf<-dcast(pars[pars$par %in% c("beta1","beta2","beta3","alpha"),], species +Chain + Draw~par,value.var="estimate")

#Turn to 
castdf$species<-factor(castdf$species,levels=1:max(as.numeric(castdf$species)))

species.split<-split(castdf,list(castdf$species),drop = T)

species.traj<-list()

for(d in 1:length(species.split)){
  dat<-species.split[[d]]
  index<-unique(dat$species)
  
  #get data for those species
  billd<-obsf[obsf$jBird %in% index,]

  #Calculate interaction effect
  species.traj[[d]]<-intF(alpha=dat$alpha,beta1=dat$beta1,x=billd$Traitmatch,resources=billd$BFlowerA,beta2=dat$beta2,beta3=dat$beta3,type='hdi')
  
  }

names(species.traj)<-names(species.split)
species.traj<-melt(species.traj,id.var=colnames(species.traj[[1]]))

#split out names and model
species.traj[,c("Index")]<-colsplit(species.traj$L1,"\\.",c("Index"))

spe<-merge(species.traj,jagsIndexBird,by.x="Index",by.y="jBird")

#match colnames

#plot and compare to original data
ggplot(data=spe,aes(x=x)) + geom_ribbon(aes(ymin=lower,ymax=upper,fill=Hummingbird),alpha=0.3) + geom_line(aes(y=mean,col=Hummingbird),size=1) + theme_bw() + xlab("Difference between Bill and Corolla Length")  + ylab("Effect of Resources on Trait Matching") + facet_wrap(~Hummingbird,scales="free")
```

#Interaction density functions
Let's take a closer look at distribution of interaction effect posteriors values for each species.

```{r}
post<-pars %>% filter(par %in% "beta3") %>% group_by(species) %>% summarize(mean=mean(estimate),median=median(estimate),lower=quantile(probs=0.025,estimate),upper=quantile(probs=0.975,estimate),hdi_l=hdi(estimate)[[1]],hdi_u=hdi(estimate)[[2]]) %>% melt(id.vars='species')
ggplot(pars[pars$par %in% "beta3",],aes(x=estimate)) + geom_histogram() + facet_wrap(~species,scales='free',ncol=3) + geom_vline(data=post,aes(xintercept=value,col=variable))
```

###Interaction and Bill Length

```{r}
#species names
b<-pars[pars$par %in% "beta3",]
b<-merge(b,jagsIndexBird,by.x="species",by.y="jBird")

#traits
b<-merge(b,hum.morph,by.x="Hummingbird",by.y="English")
#get order of mean posterior
ord<-post %>% filter(variable=="mean") %>% arrange(value) %>% .$Hummingbird

b$species<-factor(b$species,levels=ord)
ggplot(b,aes(y=estimate,x=Hummingbird,fill=Total_Culmen)) + geom_violin() + coord_flip() + scale_fill_continuous(low='blue',high='red') + ggtitle("Interaction Effect and Bill Length") + theme_bw()

```

#Detection Probability
```{r}
b<-pars[pars$par %in% "detect",]
b<-merge(b,jagsIndexBird,by.x="species",by.y="jBird")

#traits
b<-merge(b,hum.morph,by.x="Hummingbird",by.y="English")
#get order of mean posterior
ord<-post %>% filter(variable=="mean") %>% arrange(value) %>% .$Hummingbird

b$species<-factor(b$species,levels=ord)
ggplot(b,aes(y=estimate,x=Hummingbird)) + geom_violin(fill='black') + coord_flip()  + ggtitle("Detection Probability") + theme_bw()
```

```{r}
dp<-group_by(pars[pars$par %in% c("detect"),],species) %>% summarise(mean=round(mean(estimate,na.rm=T),3)*100,lower=round(quantile(estimate,0.025,na.rm=T),3)*100,upper=round(quantile(estimate,0.975,na.rm=T),3)*100) %>% arrange(mean)

tab<-merge(dp,jagsIndexBird,by.x="species",by.y="jBird")[,-1]
tab<-tab[,c(4,1,2,3)]
tab[order(tab$mean),]

write.csv(tab[,c(4,1,2,3)],"Figures/Table1.csv")
```

#Model Evaluation

Correlation coefficient among posteriors

```{r}
castdf<-dcast(pars[pars$par %in% c("gamma1","gamma2","gamma3","intercept"),], Chain + Draw~par,value.var="estimate")

ggpairs(castdf[,c("gamma1","gamma2","gamma3","intercept")])

castdf<-dcast(pars[pars$par %in% c("alpha","beta1","beta2","beta3","detect"),], Chain + Draw+species~par,value.var="estimate")

ggpairs(castdf[,c("alpha","beta1","beta2","beta3","detect")])

```

##Posterior Check

```{r,fig.height=4,fig.width=8,eval=T}
fitstat<-droplevels(pars[pars$par %in% c("fit","fitnew"),])
fitstat<-dcast(fitstat,Draw+Chain~par,value.var="estimate")

#add 1:1 line
ymin<-round(min(c(fitstat$fit,fitstat$fitnew)))
ymax<-round(max(c(fitstat$fit,fitstat$fitnew)))
ab<-data.frame(x=ymin:ymax,y=ymin:ymax)

p<-ggplot(fitstat,aes(x=fit,y=fitnew)) + geom_point() + theme_bw() + coord_equal()
psim5<-p  + labs(x="Discrepancy of observed data",y="Discrepancy of replicated data",col="Model") + geom_line(data=ab,aes(x=x,y=y)) + ggtitle("Simulated Data")

psim5
```

#What is the model missing?

```{r}
pp<-pars %>% dplyr::filter(par %in% "E") %>% group_by(parameter,species) %>% summarize(chisq=mean(estimate))

#extract row
pp$Index<-as.numeric(str_match(pp$parameter,pattern="\\[(\\d+)]")[,2])

#add to original data
obsf$chisq<-pp$chisq
```

Order predictions from worst to best.

```{r}
chiorder<-obsf %>% arrange(desc(chisq),Bird)
head(chiorder[,c("Hummingbird","Iplant_Double","chisq","Yobs","FlowerA","Traitmatch")],10)

#order `by highest average discrepancy
chi<-obsf
ord<-chi %>% dplyr::group_by(Hummingbird) %>% summarize(m=mean(chisq)) %>% arrange(desc(m)) %>% dplyr::select(Hummingbird) 
chi$Species<-factor(chi$Hummingbird,levels=ord$Hummingbird)

ord<-chi %>% dplyr::group_by(Iplant_Double) %>% summarize(m=mean(chisq)) %>% arrange(desc(m)) %>% dplyr::select(Iplant_Double) 
chi$Iplant_Double<-factor(chi$Iplant_Double,levels=ord$Iplant_Double)

ggplot(chi,aes(x=Hummingbird,y=Iplant_Double,fill=chisq)) + geom_tile() + theme_bw() + labs(fill="Chi-squared discrepancy") + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + scale_fill_gradientn(na.value="white",colours=c("white","blue","red"))
```

```{r}
save.image("Observed.RData")
```
