---
title: "Trait-matching Simulation"
author: "Ben Weinstein"
date: "July 27, 2015"
output: 
html_document:
  keep_md:true
---


```{r,warning=FALSE,message=FALSE,echo=FALSE,cache=FALSE}
library(reshape2)
library(chron)
library(ggplot2)
library(knitr)
library(R2jags)
library(dplyr)
library(stringr)
library(gridExtra)
library(boot)
library(picante)
library(bipartite)

opts_chunk$set(message=FALSE,warning=FALSE,fig.width=5,fig.height=4,echo=TRUE,cache=TRUE,cache.path = 'jp_cache/',fig.align='center',fig.path="figure/")

set.seed(3)
#source functions

source("BayesFunctions.R")
```

#Simulation   

I first create data with constant detection for each hummingbird speices, and the interaction frequency is a function of a species hierarcichal model and corolla similarity * resource availability. There is uneven sampling among species.

### Parameters

* 10 hummingbird species
* Range of hummingbird bill sizes (mm) ~ Pois(2)
* Twenty plants
* Range of corolla sizes (mm) ~ Pois(2)
* Mean frequeny ($\lambda$) for each hummingbird is drawn from U(0,10)  
* For each plant the occupancy is N($\lambda$,0.2) (truncated 0-1) 
* Trait matching (minimizing Bill-Corolla difference) is drawn from a hierarcichal distribution
$$log(\lambda)<-\alpha_i + \beta_i *traitmatch$$
$$\alpha=N(3,.01)$$
$$\beta = N(-.01,.001)$$

* Imperfect detection 
* $p_i = U(0,1)$ 
* 24 month replicates
* Phenology = .5 (plants are in flower/present .5 of surveys)


Increased occurrence with resources
* $$\Beta2 = N(.5,.001)$$

The strength of trait matching increases with available resources
* $$\Beta3 = N(.5,.001)$$

**View simulated strength and form of trait matching **

```{r,fig.height=5,fig.width=8}
sim<-function(gamma,gamma2,gamma3){
#Number of hummingbird species
h_species=10
plant_species=20
months=24
detection=runif(h_species,0,1)
phenology=.75

#Bill sizes
Bill<-rpois(h_species,10)

#Corolla sizes
Corolla<-rpois(plant_species,15)

#Subtract both and take absolute value
traitmatch<-abs(sapply(Corolla,function(x) x - Bill)/10)

#fill out for each month
traitarray<-array(NA,dim=c(h_species,plant_species,months))
#fill for each month
for (x in 1:months){
  traitarray[,,x]<-traitmatch 
}

#simulate some poisson distributed resource counts for each replicate
#this will be same for each species to start with.
resources<-array(NA,dim=c(h_species,plant_species,months))

#fill for each month
for (x in 1:months){
  resources[,,x]<-rpois(1,150)  
}

#standardize predictors

resources<-array(data=scale(resources),dim=c(h_species,plant_species,months))
traitarray<-array(data=scale(traitarray),dim=c(h_species,plant_species,months))

#regression slope for trait-matching and resources
#trait match
#gamma=-0.5
intercept<-3
sigma_slope<- 0.001
sigma_intercept<- 0.001

#resources
#gamma2=0
sigma_slope2<- 0.001

#resources * traitmatch
#gamma3=0
sigma_slope3<- 0.001

#draw values from hierarcichal distributions
beta<-rnorm(h_species,gamma,sigma_slope)
beta2<-rnorm(h_species,gamma2,sigma_slope)
beta3<-rnorm(h_species,gamma3,sigma_slope)

alpha<-rnorm(h_species,intercept,sigma_intercept)

#fit regression
lambda<-exp(alpha + beta * traitarray + beta2 * resources + beta3 * resources * traitarray)

true_interactions<-array(data=sapply(lambda,function(x){rpois(1,x)}),dim=c(h_species,plant_species,months))

#combine and melt into a single datafFrame
mdat<-dcast(melt(list(y=true_interactions,traitmatch=traitarray,resources=resources)),Var1+Var2+Var3~L1)
return(mdat)}
```

Simulate a variety of patterns to understand the relationship among the variables

1. Species interactions are based solely on trait matching. No effect of resources and no interaction effect.

```{r}
mdat<-sim(-.5,0,0)
ggplot(mdat,aes(col=resources,y=y,x=traitmatch)) + geom_point() + geom_smooth(aes(group=1),method="glm",family="poisson",formula=y~x) + theme_bw() + labs(x="Bill-Corolla Difference",y="Occurrences","Hummingbird") + ggtitle("Correlation in Simulated Data") + labs(col="Available Resources") + scale_color_continuous(low="blue",high="red",breaks=c(-2,0,1.5),labels=c("Resource Poor","","Resource Rich"))
```

2. Species interactions are based on similiarity in morphology and abundance of resources, without an interaction. As resources increase, species interact more with all resources. Red on top, blue on the bottom.

```{r}
mdat<-sim(-.5,.5,0)
ggplot(mdat,aes(col=resources,y=y,x=traitmatch)) + geom_point() + geom_smooth(aes(group=1),method="glm",family="poisson",formula=y~x) + theme_bw() + labs(x="Bill-Corolla Difference",y="Occurrences","Hummingbird") + ggtitle("Correlation in Simulated Data") + labs(col="Available Resources") + scale_color_continuous(low="blue",high="red",breaks=c(-2,0,1.5),labels=c("Resource Poor","","Resource Rich"))
```


3. Species interactions are based on similiarity in morphology and abundance of resources, without an interaction. As resources decrease, species interact more with all resources. Blue on top, red on the bottom.

```{r}
mdat<-sim(-.5,-.5,0)
ggplot(mdat,aes(col=resources,y=y,x=traitmatch)) + geom_point() + geom_smooth(aes(group=1),method="glm",family="poisson",formula=y~x) + theme_bw() + labs(x="Bill-Corolla Difference",y="Occurrences","Hummingbird") + ggtitle("Correlation in Simulated Data") + labs(col="Available Resources") + scale_color_continuous(low="blue",high="red",breaks=c(-1.5,0,1.5),labels=c("Resource Poor","","Resource Rich"))
```

4. Species interactions are based on similiarity in morphology and abundance of resources, with an interaction. As resources decrease, hummingbirds interact more with plant that match their bill length. The position of red

```{r}
mdat<-sim(-.5,0,.4)
ggplot(mdat,aes(col=resources,y=y,x=traitmatch)) + geom_point() + geom_smooth(aes(group=1),method="glm",family="poisson",formula=y~x) + theme_bw() + labs(x="Bill-Corolla Difference",y="Occurrences","Hummingbird") + ggtitle("Correlation in Simulated Data") + labs(col="Available Resources") + scale_color_continuous(low="blue",high="red",breaks=c(-1.5,0,1.5),labels=c("Resource Poor","","Resource Rich"))
```

4. Species interactions are based on similiarity in morphology and abundance of resources, with an interaction. As resources decrease, hummingbirds interact more with plant that match their bill length. The position of red

```{r}
mdat<-sim(-.5,0,-.4)
ggplot(mdat,aes(col=resources,y=y,x=traitmatch)) + geom_point() + geom_smooth(aes(group=1),method="glm",family="poisson",formula=y~x) + theme_bw() + labs(x="Bill-Corolla Difference",y="Occurrences","Hummingbird") + ggtitle("Correlation in Simulated Data") + labs(col="Available Resources") + scale_color_continuous(low="blue",high="red",breaks=c(-1.5,0,1.5),labels=c("Resource Poor","","Resource Rich"))
```

For this manuscript we are most interested in the interaction effect. Let's look at that estimate for each of the cases we just outlined.

```{r}
sim1<-sim(.5,0,0)
sim2<-sim(.5,.5,0)
sim3<-sim(.5,-.5,0)
sim4<-sim(.5,.1,.5)
sim5<-sim(.5,.1,-.5)
sims<-list(sim1,sim2,sim3,sim4,sim5)
names(sims)<-as.character(1:5)

s<-melt(sims,id.vars=colnames(sim1))

glm(data=sim1,y~resources*traitmatch,family="poisson")
```

### True Interaction Matrix

```{r,fig.width=12}
#Reshape into a nicer format
colnames(mdat)<-c("Hummingbird","Plant","Bill_Diff","True_State")

trueplot<-ggplot(mdat,aes(y=as.factor(Plant),x=as.factor(Hummingbird),fill=True_State)) + geom_tile() + labs(x="Hummingbird",y="Plant",fill="Presence") + ggtitle("True State ") + scale_fill_continuous(low="white",high="red","Occurrences")
```

```{r,fig.width=11,fig.height=4}
##Simulate detection 

#for each species loop through and create a replicate dataframe
obs<-array(dim=c(h_species,plant_species,months))

#Which months are plants in bloom?
#This is the phenology matrix
sampled<-replicate(plant_species,rbinom(months,1,phenology))
sampled[sampled==0]<-NA

for(x in 1:h_species){
  for (y in 1:plant_species){
    
    #True State
    ts<-true_interactions[x,y]
    
    #detections are function of phenology detection probability and occupancy
    det<-rbinom(months,ts,detection[x])
    
    #detections and phenology
    obs[x,y,]<-det *sampled[,y]
    }
  }

#plot observed state
obs.state<-melt(obs)
colnames(obs.state)<-c("Hummingbird","Plant","Month","Detections")

#turn NA's to 0
obs.state$Detections[is.na(obs.state$Detections)]<-0

obs.state$Hummingbird<-as.factor(obs.state$Hummingbird)
obs.state$Plant<-factor(obs.state$Plant,levels=1:plant_species)

ob1<-ggplot(obs.state[obs.state$Month==12,],aes(x=Hummingbird,y=Plant,fill=Detections)) + geom_tile() + scale_fill_continuous(low="white",high="Red",limits=c(0,max(mdat$True_State))) + ylab("Plant") + ggtitle("Example 1") + xlab("Hummingbird")

ob2<-ggplot(obs.state[obs.state$Month==18,],aes(x=Hummingbird,y=Plant,fill=Detections)) + geom_tile() + scale_fill_continuous(low="white",high="Red",limits=c(0,max(mdat$True_State))) + ylab("Plant") + ggtitle("Example 2") + xlab("Hummingbird")

grid.arrange(trueplot,ob1,ob2,nrow=1)
```

The left hand panel is the true state for each hummingbird plant combination. The middle and right hand panel are two realizations that might result from a month of sampling given incomplete detection and phenology.

```{r}
d<-merge(mdat,obs.state)
ggplot(d,aes(x=True_State,y=Detections,col=Month)) + geom_point() + theme_bw() + geom_abline() + coord_equal()
```

### Model Fitting
## Hierarcichal Occupancy Model Formulation

$$ Y_{i,j,k} \sim Binom(N_{i,j},detect_i)$$
$$N_{i,j} \sim Pois(\lambda_{i,j}) $$
$$log(\lambda_{i,j})<-\alpha_i + \beta_i * abs(Bill_i - Corolla_i) $$
$$detect_i \sim U(0,1)$$     

**Priors**

$$\alpha_i \sim N(intercept,\tau_{\alpha})$$
$$\beta_i \sim N(\gamma,\tau_{\beta})$$

**Hyperpriors**
$$gamma \sim N(0.001,0.001)$$
$$intercept \sim N(0.001,0.001)$$

$$\tau_{\alpha} \sim Gamma(0.001,0.001)$$
$$\tau_\beta \sim Gamma(0.001,0.001)$$

**Derived quantities**

$$\sigma_{int} = \frac{1}{\tau_{\alpha}}^2$$
$$\sigma_{slope} = \frac{1}{\tau_{\beta}}^2$$

##Hierarcichal Bayesian Model with detection

```{r,eval=T}
setwd("C:/Users/Ben/Documents/Occupy/")
runs<-20000

#Source model
source("Bayesian/NMixture.R")

#print model
print.noquote(readLines("Bayesian/NMixture.R"))

#Input Data
Dat <- list(
  Y=obs,
  Birds=dim(obs)[1],
  Plants=dim(obs)[2],
  Months=dim(obs)[3],
  traitmatch=traitmatch)

#A blank Y matrix - all present
initY<-array(dim=c(Dat$Birds,Dat$Plants),data=max(obs,na.rm=T))

#Inits
InitStage <- function() {list(beta=rep(.5,Dat$Birds),alpha=rep(.5,Dat$Birds),detect=rep(.5,Dat$Birds),intercept=0,tau_alpha=0.1,tau_beta=0.1,N=initY,gamma=0)}

#Parameters to track
ParsStage <- c("detect","alpha","beta","intercept","sigma_int","sigma_slope","N","gamma","fit","fitnew")

#MCMC options
ni <- runs  # number of draws from the posterior
nt <- runs*.001   #thinning rate
nb <- runs*.2 # number to discard for burn-in
nc <- 3  # number of chains

#Jags

m = jags(inits=InitStage,
         n.chains=nc,
         model.file="Bayesian/NMixture.jags",
         working.directory=getwd(),
         data=Dat,
         parameters.to.save=ParsStage,
         n.thin=nt,
         n.iter=ni,
         n.burnin=nb,
         DIC=T)
```

```{r}
pars<-extract_par(m)
```

###Assess Convergence

```{r,cache=FALSE,eval=TRUE,fig.width=11,fig.height=5}

###Chains
ggplot(pars[pars$par %in% c("detect","alpha","beta"),],aes(x=Draw,y=estimate,col=as.factor(Chain))) + geom_line() + facet_grid(par~species,scale="free") + theme_bw() + labs(col="Chain") + ggtitle("Detection Probability")

```

```{r,fig.height=5,fig.width=11,eval=T}
ggplot(pars[pars$par %in% c("gamma","sigma_int","sigma_slope"),],aes(x=Draw,y=estimate,col=as.factor(Chain))) + geom_line() + theme_bw() + labs(col="Chain") + ggtitle("Trait-matching regression") + facet_wrap(~par,scales="free")
```

###Posteriors

```{r,cache=FALSE,fig.width=7,fig.height=5}
###Posterior Distributions
p<-ggplot(pars[pars$par %in% c("detect","alpha","beta"),],aes(x=estimate)) + geom_histogram() + ggtitle("Estimate of parameters") + facet_grid(species~par,scales="free") + theme_bw() + ggtitle("Species Posteriors")

#Add true values
tr<-melt(data.frame(species=1:length(detection),detect=detection,alpha=alpha,beta=beta),id.var='species')
colnames(tr)<-c("species","par","value")
psim<-p + geom_vline(data=tr,aes(xintercept=value),col='red',linetype='dashed',size=1)
#ggsave("Figures/SimulationPosteriors.jpg",dpi=300,height=8,width=8)
```

```{r,cache=FALSE,eval=TRUE,fig.height=3,fig.width=10}

p<-ggplot(pars[pars$par %in% c("gamma","polygamma","intercept","sigma_int","sigma_slope","sigma_polyslope"),],aes(x=estimate)) + geom_histogram() + ggtitle("Hierarchical Posteriors") + facet_grid(~par,scale="free") + theme_bw() 

#Add true values
tr<-melt(list(gamma=gamma,intercept=intercept,sigma_int=sigma_intercept,sigma_slope=sigma_slope))

colnames(tr)<-c("value","par")

psim2<-p + geom_vline(data=tr,aes(xintercept=value),linetype='dashed',size=1,col="black")
#ggsave("Figures/SimulationH.jpg",dpi=300,height=4,width=10)
```

**True values are given in the dashed lines.**

###Compare estimates with and without detection

```{r,cache=FALSE,fig.width=7,fig.height=5}
pars$Model<-"Detection"

#Bind to other dataset
parsall<-rbind.data.frame(pars,pars_niave)
parsall$Model<-as.factor(parsall$Model)

###Posterior Distributions
p<-ggplot(parsall[parsall$par %in% c("detect","alpha","beta"),],aes(x=estimate,fill=Model)) + geom_histogram() + ggtitle("Estimate of parameters") + facet_grid(species~par,scales="free") + theme_bw() 

#Add true values
tr<-melt(data.frame(species=1:length(detection),detect=detection,alpha=alpha,beta=beta),id.var='species')
colnames(tr)<-c("species","par","value")
psim<-p + geom_vline(data=tr,aes(xintercept=value),col='black',linetype='dashed',size=1)
psim
#ggsave("Figures/SimulationPosteriorsBoth.jpg",dpi=300,height=8,width=8)
```

```{r,cache=FALSE,eval=TRUE,fig.height=3,fig.width=10}

p<-ggplot(parsall[parsall$par %in% c("gamma","polygamma","intercept","sigma_int","sigma_slope","sigma_polyslope"),],aes(x=estimate,fill=Model)) + geom_histogram() + ggtitle("Hierarchical Posteriors") + facet_grid(~par,scale="free") + theme_bw() 

#Add true values
tr<-melt(list(gamma=gamma,intercept=intercept,sigma_int=sigma_intercept,sigma_slope=sigma_slope))

colnames(tr)<-c("value","par")

psim2<-p + geom_vline(data=tr,aes(xintercept=value),linetype='dashed',size=1,col="black")
psim2
#ggsave("Figures/SimulationHBoth.jpg",dpi=300,height=4,width=10)
```

###Predicted Relationship 

Does accounting for non-independence and detection change our estimate of trait matching?

```{r,fig.height=4,fig.width=4}

castdf<-group_by(pars,Chain) %>% sample_n(2000)%>% select(par,estimate) %>% filter(par %in% c("gamma","intercept"))

castdf<-dcast(pars[pars$par %in% c("gamma","intercept"),], Chain + Draw~par,value.var="estimate")

trajF<-function(alpha,beta,x){
  indat<-cbind(alpha,beta)
  
  #fit regression for each input estimate
  sampletraj<-apply(indat,1,function(s){
    data.frame(x=x,y=exp(s['alpha'] + s['beta'] *x))})
  sample_all<-rbind_all(sampletraj)
  
  #Compute CI intervals
  predy<-group_by(sample_all,x) %>% summarise(lower=quantile(y,0.025,na.rm=T),upper=quantile(y,0.975,na.rm=T),mean=mean(y,na.rm=T))
  }

#calculated predicted y
predy<-trajF(alpha=castdf$intercept,beta=castdf$gamma,x=as.numeric(traitmatch))

orig<-trajF(alpha=rnorm(2000,intercept,sigma_intercept),beta=rnorm(2000,gamma,sigma_slope),x=as.numeric(traitmatch))


#plot and compare to original data
psim3<-ggplot(data=predy,aes(x=x)) + geom_ribbon(aes(ymin=lower,ymax=upper),alpha=0.1,fill="red")  + geom_line(aes(y=mean),size=.8,col="red",linetype="dashed") + theme_bw() + ylab("Interactions") + geom_line(data=orig,aes(x=x,y=mean),col='black',size=1) + geom_ribbon(data=predyniave,aes(ymin=lower,ymax=upper),alpha=0.1,fill="blue") +  geom_line(data=predyniave,aes(y=mean),size=.8,col="blue",linetype="dashed") + xlab("Difference between Bill and Corolla Length") 

psim3
ggsave("Figures/SimulationResults.jpg",height=5,width=6,dpi=300)
```

Black line is the true relationship. The red line is the posterior mean with confidible intervals in shaded grey for the proposed bayesian model. The poisson glm that does not account for detectability or non-independence is in blue.

**Conclusion:** Accounting for detection and non-independence greatly increases the accuracy of the predicted state. The poisson glm underestimates the strength of trait matching among hummingbirds and their foodplants.

###Predicted Frequency

Validating the model

```{r,eval=T}

#any given state
predState<-group_by(parsall,par,Model) %>% filter(par=="N") %>% group_by(par,species,plant,Model) %>% summarize(State=as.numeric(names(which.max(table(estimate)))))

predState$species<-as.factor(predState$species)
predState$plant<-factor(predState$plant,levels=1:plant_species)

predplot<-ggplot(predState,aes(x=species,y=plant,fill=State)) + geom_tile() + scale_fill_continuous(na.value="white",low="white",high="red",limits=c(0,max(obs.state$Detection))) + labs(x="Hummingbird",y="Plant",fill="Predicted State") + ggtitle("Predicted") + facet_wrap(~Model)

#compare true and pred states
tr<-melt(true_interactions)
colnames(tr)<-c("Hummingbird","Plant","True_State")

mdat<-merge(predState,tr,by.x=c("species","plant"),by.y=c("Hummingbird","Plant"))

ggplot(mdat,aes(y=State,x=True_State,col=Model)) + geom_point(size=3) + geom_abline(linetype="dashed") + theme_bw() + xlab("True State") + ylab("Predicted State") + coord_equal()
```

###Posterior Check

Since I have simualted the data, it should fit as well as any random dataset drawn from the estimated parameters. An ideal fit would be posterior values sitting along the 1:1 line.

```{r,fig.height=4,fig.width=8}

fitstat<-droplevels(parsall[parsall$par %in% c("fit","fitnew"),])
fitstat<-dcast(fitstat,Draw+Chain+Model~par,value.var="estimate")

#add 1:1 line

ymin<-round(min(c(fitstat$fit,fitstat$fitnew)))
ymax<-round(max(c(fitstat$fit,fitstat$fitnew)))
ab<-data.frame(x=ymin:ymax,y=ymin:ymax)
p<-ggplot(fitstat,aes(x=fit,y=fitnew)) + geom_point(aes(col=Model)) + theme_bw() + coord_equal()
psim4<-p  + labs(x="Discrepancy of observed data",y="Discrepancy of replicated data",col="Model") + geom_line(data=ab,aes(x=x,y=y)) + ggtitle("Simulated Data")

psim4

#Write Figures as panels
jpeg("Figures/SimulationPosteriorsBoth.jpg",height=12,width=12,units="in",res=300)
grid.arrange(psim,psim2,ncol=1,heights=c(3/4,1/4))
dev.off()

jpeg("Figures/SimPredictBoth.jpg",height=6,width=7,units="in",res=300)
grid.arrange(psim3)
dev.off()
```

