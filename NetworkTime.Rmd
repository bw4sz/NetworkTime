---
title: Niche overlap increases with increasing resource availability in a tropical
  plant-pollinator network.
author: "Ben Weinstein"
date: "Tuesday, October 14, 2014"
output:
  html_document:
    theme: spacelab
  word_document: default
---

```{r,echo=FALSE,warning=FALSE,message=FALSE}
require(knitr)
library(R2jags)
require(reshape2)
require(ggplot2)
library(scales)
library(dplyr)
library(stringr)
require(picante)
require(igraph)
require(bipartite)
library(chron)
library(gridExtra)

#Set Dropbox Location
#setwd to dropbox
droppath<-"C:/Users/Ben/Dropbox/"

#Set github path
gitpath<-"C:/Users/Ben/Documents/NetworkTime/"

setwd(gitpath)

opts_chunk$set(message=FALSE,warning=FALSE,fig.height=9,fig.width=13,echo=FALSE,cache=TRUE,cache.path = 'NetworkTime_cache/', fig.path='figure/')

#source bayes functions
source("Bayesian/BayesFunctions.R")
```

#Exploratory Network Analysis

```{r}
#Exploratory analysis
#source("Network.R")
```

************
**Figure 1. Conceptual figure showing patterns of interactions between birds and flowers for high and low niche overlap, connectance and clustering. The bottom panel shows two hypothezied relationship between available resources, specialization, and trait matching.**

![ConceptualFigure](C:\Users\Ben\Documents\NetworkTime\Figures\ConceptualFigure.png)

************
#Deliniate high and low resource availability periods.

* A resource transect is one that is in the top quartile

```{r}
#Sum floral resources for each transect

#Label each
```

**Figure 2. Flower abundance per month for each transect. **

```{r}
#Get flower transect data
full.fl<-read.csv("C:/Users/Ben/Dropbox/Thesis/Maquipucuna_SantaLucia/Results/FlowerTransects/FlowerTransectClean.csv")[,-1]

 #month should be capital 
colnames(full.fl)[colnames(full.fl) %in% "month"]<-"Month"

#group by month and replicate, remove date errors by making a max of 10 flowers, couple times where the gps places it in wrong transect by 1 to 2 meters. 
flower.month<-group_by(full.fl,Month,Year,Transect_R,Date_F) %>% dplyr::summarise(Flowers=sum(Total_Flowers,na.rm=TRUE))  %>% filter(Flowers>20)
  
#Make month abbreviation column, with the right order
flower.month$Month.a<-factor(month.abb[flower.month$Month],month.abb[c(1:12)])

#Make year factor column
flower.month$Year<-as.factor(flower.month$Year)

#get quantile for each transect
thresh<-melt(group_by(flower.month,Transect_R) %>% summarize(Threshold=quantile(log(Flowers),0.666)) )
flower.month<-merge(flower.month,thresh)
flower.month$High<-log(flower.month$Flowers)>flower.month$value
#plot
ggplot(flower.month,aes(x=Month.a,log(Flowers),shape=as.factor(Year),col=High)) + geom_point(size=3) + theme_bw()  + geom_smooth(aes(group=1)) + ylab("Flowers") + xlab("Month") + facet_wrap(~Transect_R,scales="free_y") + labs(shape="Year", y= "Log Available Flowers") + scale_x_discrete(breaks=month.abb[seq(1,12,2)]) + scale_color_manual(labels=c("Low","High"),values=c("black","red")) + labs(col="Resource Availability")

ggsave("Figures/AvailableFlowers.jpg",dpi=600,units="in",width=11,height=10)
ggsave("Figures/AvailableFlowers.svg",units="in",width=11,height=10)

```

****

**Figure 3. Measures of hummingbird plant interactions through time (points) as compared to a null model maintaining the number of observations (shaded region).The size of the point is proportional to the number of interactions measured for each month.**

```{r,fig.width=14}
#Goal to create randomized networks for each month and redo the entire analysis

int<-read.csv(paste(droppath,"Thesis/Maquipucuna_SantaLucia/Results/Network/HummingbirdInteractions.csv",sep=""),row.names=1)
int$Year<-years(int$DateP)
int$Year[int$Year %in% 2012]<-2013

int[int$Year %in% 2013 & int$Month %in% 1,"Year"]<-2014

#break up network by two months
int.M<-split(int,list(int$Month,int$Year),drop=TRUE)

#remove months with less than 15 records
int.M<-int.M[sapply(int.M,nrow)>20]

#design null function
nullC<-function(x){
  x<-droplevels(x)
  N=nrow(x)
  month.inter<-t(table(x$Hummingbird,x$Iplant_Double))
  #month.interB<-(month.inter>0)*1

metricskeep<-c("connectance","cluster coefficient","niche overlap","togetherness","linkage density","partner diversity","mean number of shared partners","nestedness","number of compartments","weighted connectance")

true_stat<-networklevel(month.inter)
  
true_stat<-melt(true_stat)

true_stat$variable<-rownames(true_stat)

# Create 199 random matrixes
r.int<-permatfull(month.inter,times=50,fixedmar="columns")

#Compute nestendness seperately.
nested.test<-nestedness(month.inter)

#Create a function that computes network metrics
null_total<-as.data.frame(
  t(sapply(r.int$perm,function(x){
  #Compute network statistics
    out<-networklevel(x)
    return(out)
    })))
#get the upper and lower 2.5th quantiles
null_total<-melt(null_total)
nullq<-group_by(null_total,variable) %>% summarize(Lower=quantile(value,0.025,na.rm=T),Upper=quantile(value,0.975,na.rm=T))

#add month
nullq$Month<-unique(x$Month)

#add Year
nullq$Year<-unique(x$Year)

colnames(nullq)<-c("Metric","Lower","Upper","Month","Year")

#append true information
out<-merge(nullq,true_stat,by.x="Metric",by.y="variable")
colnames(out)[colnames(out) %in% "value"]<-"True"
out$N<-N
return(out)}

#apply function to each month
dat<-rbind_all(lapply(int.M,nullC))

#format date
dat$Date<-as.Date(paste(1,round(dat$Month),dat$Year,sep="/"),format="%d/%m/%Y")

#Take out plant metrics for the moment
datHL<-dat[!str_detect(dat$Metric,".LL"),]

#plot distribution of  values
p<-ggplot(datHL,aes(x=Date,fill=Metric)) + facet_wrap(~Metric,scales='free') + geom_ribbon(aes(ymin=Lower,ymax=Upper))
p<-p+ geom_point(aes(size=N,y=True)) + geom_line(aes(y=True)) 
p<-p+scale_fill_discrete(guide="none") + scale_x_date(breaks="3 months",label=date_format("%m/%y")) + scale_size_continuous(range=c(2.5,5),"Observations") + labs(y="") + theme_bw()
print(p) 

ggsave("Figures/NullNetwork.jpg",dpi=600,quality=100,pointsize=14,height=10,width=12)
ggsave("Figures/NullNetwork.svg",height=10,width=12)

```

********

**Figure 4. Connectance, clustering and niche overlap as a function of available resources. Point size is proportional to number of interactions observed that month.**

```{r,fig.height=20,fig.width=15}
    
flowerMean<-group_by(flower.month,Month,Year,Transect_R) %>% summarize(mFlowers=mean(Flowers,na.rm=TRUE)) %>% group_by(Month,Year) %>% summarize(Flowers=sum(mFlowers,na.rm=TRUE))
  
#combine the flower totals and network metrics
  network.fl<-merge(flowerMean,datHL,by=c("Month","Year"))
  
  #Quick visualization 
  p<-ggplot(network.fl[,],aes(log(Flowers),y=True,shape=as.factor(Year))) + geom_point(aes(size=N)) + facet_wrap(~Metric,scale="free")  + geom_smooth(aes(group=1),method="lm") + theme_bw() + labs(col="Month",shape="Year",size="Interactions") + geom_text(aes(label=month.abb[Month]),hjust=-0.25,size=3) + scale_size_continuous(range=c(2.5,5),"Observations") + labs(x="Log Available Resources") + ylab("Score")
  print(p) 
ggsave("Figures/Network_Resources.jpg",height=15,width=15,dpi=300,units="in")
ggsave("Figures/Network_Resources.svg",height=10,width=10)

#just a subset
p<-ggplot(network.fl[network.fl$Metric %in% c("mean.number.of.shared.partners.HL","H2","weighted NODF","connectance"),],aes(log(Flowers),y=True,shape=as.factor(Year))) + geom_point(aes(size=N)) + facet_wrap(~Metric,scale="free")  + geom_smooth(aes(group=1),method="lm") + theme_bw() + labs(col="Month",shape="Year",size="Interactions") + geom_text(aes(label=month.abb[Month]),hjust=-0.25,size=3) + scale_size_continuous(range=c(2.5,5),"Observations") + labs(x="Log Available Resources") + ylab("Score")
  print(p) 
ggsave("Figures/Network_ResourcesSubset.jpg",height=5,width=10,dpi=300,units="in")
ggsave("Figures/Network_ResourcesSubset.svg",height=5,width=10)
  
```

## Figure 5. Trait matching

I'm not sure which of the following figures best show what i believe is happenning. The essential idea is:

* Hummingbirds in general match the corolla resources based on their bill length.

* This relationship changes over time

* During periods of high resource availability, trait matching is decreased. This is most pronounced in long billed species.

```{r,fig.width=9,fig.height=7,fig.align='center'}

#read in flower morphology data, comes from Nectar.R
fl.morph<-read.csv(paste(droppath,"Thesis/Maquipucuna_SantaLucia/Results/FlowerMorphology.csv",sep=""))

#First row is empty
fl.morph<-fl.morph[-1,]

#Bring in Hummingbird Morphology Dataset, comes from
hum.morph<-read.csv(paste(droppath,"Thesis/Maquipucuna_SantaLucia/Results/HummingbirdMorphology.csv",sep=""))

#Bring in Interaction Matrix from the Network.R script
int<-read.csv(paste(droppath,"Thesis/Maquipucuna_SantaLucia/Results/Network/HummingbirdInteractions.csv",sep=""),row.names=1)

#int$Month<-cut(int$Month,seq(0,12,2),labels=seq(1,11,2))

#Melt the interaction frame and match it with the traits
m.dat<-int[colnames(int) %in% c("ID","Video","Time","Hummingbird","Sex","TransectID","Transect_R","Iplant_Double","Pierce","DateP","Month","ele")]

m.dat$Year<-years(as.Date(m.dat$DateP))
#Fix spacing to match clades

#Which are matching
levels(m.dat$Hummingbird)[!levels(m.dat$Hummingbird) %in% hum.morph$English]

#This needs to be checked
#print(paste(levels(m.dat$Hummingbird)[!levels(m.dat$Hummingbird) %in% hum.morph$English],"not matched"))

#levels(m.dat$Hummingbird)[!levels(m.dat$Hummingbird) %in% hum.morph$English]<-c("Green-crowned Woodnymph")
m.datH<-merge(m.dat,hum.morph, by.x="Hummingbird",by.y="English")

#Merge to flowers
int.FLlevels<-levels(factor(m.datH$Iplant_Double))

#Which flowers are we missing info for?
missingTraits<-int.FLlevels[!int.FLlevels %in% fl.morph$X]

print(paste("Missing Trait Information:",missingTraits))
m.datH<-merge(m.datH,fl.morph, by.x="Iplant_Double",by.y="X")

#Drop piercing events, since they don't represent correlation
m.datH<-m.datH[!m.datH$Pierce %in% c("y","Y"),]
```

###Potential Figure

The correlation coefficient among bill and corolla lengths decreases as a function of available resources. The gray ribbon is a null randomization of the correlation structure for each month.

```{r}
#Time Cycles in correlation between bills and corollas

#Start by plotting monthly breaks of corolla matching

p<-ggplot(m.datH[!is.na(m.datH$Month),],aes(x=factor(Total_Culmen),TotalCorolla,col=Hummingbird)) + geom_point() 
p<-p + geom_smooth(aes(group=1),method="lm") + facet_wrap(~Month) + theme_bw()

p<-ggplot(m.datH[!is.na(m.datH$Month),],aes(x=Total_Culmen,TotalCorolla,col=Month)) + geom_point() 
p<-p + geom_smooth(aes(group=Month),method="lm") + theme_bw() + scale_color_continuous(low="blue",high="red")

#Difference Between Corolla and Bill Length of interactions measured
m.datH$BD<-m.datH$Total_Culmen-m.datH$TotalCorolla
p<-ggplot(m.datH,aes(y=BD,x=Hummingbird)) + geom_boxplot(position="dodge")
p<-p + coord_flip()

#######################################
#Compared usage to available resources
#######################################

sdat<-split(m.datH,list(m.datH$Month,m.datH$Year))

#atleast 10 observations
sdat<-sdat[sapply(sdat,nrow)>30]

######Correlation coefficient
#calculate it for all birds, then short and longbilled (30cm)
coeff<-rbind_all(lapply(sdat,function(x){
  mod.c<-cor(x$Total_Culmen,x$TotalCorolla)
  data.frame(Month=unique(x$Month),Year=as.numeric(as.character(unique(x$Year))),all=mod.c)
}))

#observed correlation
observed<-melt(coeff,measure.vars=c("all"))

#view observed and add date column, just call it the firt of the month for plotting
observed$Date<-as.Date(paste(observed$Month,1,observed$Year,sep="/"),format="%m/%d/%Y")
p<-ggplot(data=observed,aes(x=Date,y=value)) + geom_point() + geom_smooth(aes(group=variable)) 
p<-p+ theme_bw()  + labs(y="Correlation between Bill and Corolla Length",x="Available Resources") + labs(shape="Year")
p
ggsave("Figures/CorrelationTime.jpg",height=5,width=8,units="in",dpi=600)
ggsave("Figures/CorrelationTime.svg",height=5,width=8)

setwd(gitpath)
```

```{r,fig.height=10}

#Randomization of correlation

#Define replication function, shuffle corolla length values
shufflecor<-function(x=m.datH){
  #sample draw
  x$NewCorolla<-sample(x$TotalCorolla,replace=F)
  splitdat<-split(x,list(x$Month,x$Year))
  
  #atleast 20 observations
  splitdat<-splitdat[sapply(splitdat,nrow)>30]
  
  ######Correlation coefficient, which method to use?
  coef<-lapply(splitdat,function(y){
    mc<-cor(y$Total_Culmen,y$NewCorolla)
    
    out<-data.frame(Month=unique(y$Month),Year=as.numeric(as.character(unique(y$Year))),all=mc)
    return(out)}
    )
  nullc<-rbind_all(coef)
  return(nullc)
  }

nullcor<-replicate(100,shufflecor(m.datH),simplify = F)
nullcor<-rbind_all(nullcor)
#bind with resource dataframe
nullcor<-merge(flowerMean,nullcor,by=c("Month","Year"))

#Bind into one data frame
nullcorm<-melt(nullcor,measure.vars=c("all"))

#Get upper and lower quantile of null correlation
nullcorq<-dplyr::group_by(nullcorm,Month,Year,variable) %>% dplyr::summarize(Flowers=unique(Flowers),Upper=quantile(value,0.025),Lower=quantile(value,0.975))

#merge with original data
finaldat<-merge(nullcorq,observed)

#get data size for each month
sizeall<-group_by(m.datH,Month,Year) %>% mutate(Billtype=cut(Total_Culmen,breaks=c(0,60),labels=c("all"))) %>% group_by(Month,Year,Billtype) %>% summarize(N=n())

#bind size with observed and null data
finaldat<-merge(finaldat,sizeall)

p<-ggplot(data=finaldat,aes(x=log(Flowers),fill=variable))
p<-p+geom_ribbon(aes(ymin=Lower,ymax=Upper),fill="grey20",alpha=.15)
p<-p 
p<-p+ theme_bw()  + labs(y="Correlaton between Bill and Corolla Length",x="Log Available Resources",shape="Year",y="")

p<-p + scale_y_continuous(breaks=c(-.3,0,.2,.4,.6,.8)) + scale_size_continuous(range=c(2.5,5)) + scale_fill_discrete(guide="none") + geom_smooth(aes(y=value),method="lm",fill="grey60",alpha=.8)  + labs(size="Observations") + geom_point(aes(y=value,shape=as.factor(Year),size=N)) + geom_text(aes(y=value,label=month.abb[Month]),size=3.5,vjust=-.5)
print(p)
ggsave("Figures/TraitMatching_Resource.jpg",height=6,width=8,units="in",dpi=600)
ggsave("Figures/TraitMatching_Resource.svg",height=6,width=8)

```

* The working hypothesis is that long billed species tend to feed more on mismatched corolla values during periods of high resource abundance. 

```{r,eval=T}
specmonth<-function(x){

  monthdata<-droplevels(x)

#make interaction matrix
month.interB<-table(monthdata$Hummingbird,monthdata$Iplant_Double)

#What flowers are present
fl.present<-levels(monthdata$Iplant_Double)

sp_total<-dplyr::group_by(full.fl,Iplant_Double,Month,year) %>% filter(Iplant_Double %in% fl.present, Month %in% monthdata$Month & year %in% monthdata$Year)%>% summarize(N_Flowers=sum(Total_Flowers,na.rm=T)) %>% select(N_Flowers)

if(nrow(sp_total)==0){return(NA)}

missp<-colnames(month.interB)[!colnames(month.interB) %in% sp_total$Iplant_Double]

#get average of the month before and after if missing (pretty rare)
if(length(missp)>0){
print(paste("Abundance missing for species:",missp))
sp_missing<-dplyr::group_by(full.fl,Iplant_Double,Month,year) %>% filter(Iplant_Double %in% fl.present, Month %in% c(monthdata$Month+2,monthdata$Month-2,monthdata$Month+1,monthdata$Month,monthdata$Month-1) & year %in% monthdata$Year) %>% filter(Iplant_Double %in% missp)%>% summarize(N_Flowers=sum(Total_Flowers,na.rm=T)) %>% group_by(Iplant_Double) %>% summarize(N_Flowers=mean(N_Flowers)) %>% mutate(Month=unique(monthdata$Month))
sp_total<-rbind_all(list(sp_total,sp_missing))
}

N_Flowers<-sp_total$N_Flowers
names(N_Flowers)<-sp_total$Iplant_Double

#order 
out<-vector()
for (g in 1:length(N_Flowers)){
  ord<-match(names(N_Flowers)[g],colnames(month.interB))
  out[ord]<-N_Flowers[g]
  names(out)[ord]<-names(N_Flowers)[g]
}
spec<-H2fun(month.interB,abuns=sample(N_Flowers))
toreturn<-data.frame(Species=names(spec$dprime),Dprime=spec$dprime,Month=unique(monthdata$Month),Year=unique(monthdata$Year))
return(toreturn)
}
```

```{r,eval=F}
hlist<-list()
for(d in 1:length(sdat)){
  try(hlist[[d]]<-specmonth(sdat[[d]]))
  }

names(hlist)<-names(sdat)
#remove NA rows for today
hlist<-hlist[sapply(hlist,length)==4]
mlist<-melt(hlist,id.vars=c("Month","Year","Species"))

```

```{r,fig.height=9,eval=F}
#just keep species with atleast six months of data
spkeep<-names(which(table(mlist$Species)>=5))
mlist<-mlist[mlist$Species %in% spkeep,]
#merge with traits
mlistt<-merge(mlist,hum.morph[,colnames(hum.morph) %in% c("Mass","Total_Culmen","English")],by.x="Species",by.y="English")

mlistt$BillT<-cut(mlistt$Total_Culmen,c(0,30,70),c("Short","Long"))
```

Corolla matching versus all available resources.

```{r,fig.height=9,eval=FALSE}
#match the trait and bill data with available flowers
h2flowers<-merge(mlistt,flowerMean)

h2match<-merge(m.datH,h2flowers,by.y=c("Month","Year","Species"),by.x=c("Month","Year","Hummingbird"))

#merge with original network measures
nm<-dcast(network.fl,Month+Year~Metric,value.var="True")
h2final<-merge(h2match,nm)

p<-ggplot(h2final[!h2final$Iplant_Double %in% "Fuchsia macrostigma",],aes(x=Flowers,y=value)) + geom_smooth(method="lm") + geom_point() + geom_text(aes(label=paste(Species,Iplant_Double)),size=2)
p<-p + theme_bw()
p
```

Corolla matching versus species specific available resources. Why should species care if there are a ton of gasternathus flowers in bloom if they never use that resource? Resource scarcity may be different for each species, not synchronized.

```{r,fig.height=10}
#for each species get the list of resources.
keep<-names(which(table(m.datH$Hummingbird) > 30))

hum<-levels(m.datH$Hummingbird)
hum<-hum[hum %in% keep]
flowerh<-lapply(hum,function(h){
  #Find plant species
  plants<-m.datH %>% filter(Hummingbird==h) %>% select(Iplant_Double) %>% distinct()
  
  #Query the transect for availability of these plants
  full.fl %>% filter(Iplant_Double %in% levels(factor(plants$Iplant_Double))) %>% group_by(Month,Year,Transect_R,Date_F) %>% dplyr::summarise(Flowers=sum(Total_Flowers,na.rm=TRUE))  %>% filter(Flowers>2) %>% mutate(Hummingbird=h) %>% group_by(Month,Year,Transect_R,Hummingbird) %>% summarize(TFlowers=mean(Flowers,na.rm=T)) %>% filter(TFlowers>10)
  })
flowerh<-droplevels(rbind_all(flowerh))

#sum by transects
flowerh<-flowerh %>% group_by(Month,Year,Transect_R,Hummingbird) %>% summarize(TF=mean(TFlowers)) %>% group_by(Month,Year,Hummingbird) %>% summarize(Flowers=sum(TF))

ggplot(flowerh,aes(y=log(Flowers),x=Month,shape=as.factor(Year),fill=Hummingbird),alpha=.1) + geom_smooth(aes(group=Hummingbird)) + geom_point(size=2) + theme_bw() + scale_x_continuous(breaks=1:12,labels=month.abb) + ylab("Available Resources")

idflower<-merge(m.datH,flowerh,by=c("Month","Year","Hummingbird"))

#Get the 75% quantile for each species
th<-idflower %>% group_by(Hummingbird) %>% summarize(Threshold=quantile(log(Flowers),0.5))

idflower<-merge(idflower,th)
idflower$HL<-log(idflower$Flowers) > idflower$Threshold

#reorder species levels
ord<-idflower %>% group_by(Hummingbird) %>% summarize(BL=unique(Total_Culmen)) %>% arrange(BL)
idflower$Hummingbird <- factor(idflower$Hummingbird,levels=ord$Hummingbird)

p<-ggplot(idflower,aes(y=Total_Culmen-TotalCorolla,x=HL,fill=Total_Culmen>30)) + geom_boxplot()
p<-p + theme_bw() + facet_wrap(~Hummingbird,scales="free")
p<-p + scale_x_discrete("Available Resources",labels=c("Low","High")) + scale_fill_discrete("Bill Length",labels=c("Short","Long")) 
p + labs(y="Difference between bill and corolla Length")
ggsave("Figures/BillLength_Resources.jpg",height=7,width=10,units="in",dpi=600)
ggsave("Figures/BillLength_Resources.svg",height=7,width=10)

```

### Model Fitting
## Hierarcichal Occupancy Model Formulation

$$ Y_{i,j,k} \sim Pois(\lambda_{i,j,k}) $$

$$log(\lambda_{i,j,k})<-\alpha_i + \beta_i * abs(Bill_i - Corolla_j) * \beta_2 * Resources_k + \beta_3 * Resources_k * abs(Bill_i - Corolla_j) $$

**Priors**

$$\alpha_i \sim N(intercept,\tau_{\alpha})$$
$$\beta_{1,i} \sim N(\gamma_1i,\tau_{\beta_1})$$
$$\beta_{2,i} \sim N(\gamma_2i,\tau_{\beta_2})$$
$$\beta_{3,i} \sim N(\gamma_3i,\tau_{\beta_3})$$


**Hyperpriors**

Group Level Means

$$\gamma_{1,i} \sim N(0.001,0.001)$$
$$\gamma_{2,i} \sim N(0.001,0.001)$$
$$\gamma_{3,i} \sim N(0.001,0.001)$$
$$ intercept \sim N(0.001,0.001)$$

Group Level Variance

$$\tau_{\alpha} \sim Gamma(0.001,0.001)$$
$$\tau_\beta1 \sim Gamma(0.001,0.001)$$
$$\tau_\beta2 \sim Gamma(0.001,0.001)$$
$$\tau_\beta3 \sim Gamma(0.001,0.001)$$

**Derived quantities**

$$\sigma_{int} = \frac{1}{\tau_{\alpha}}^2$$
$$\sigma_{slope1} = \frac{1}{\tau_{\beta_1}}^2$$
$$\sigma_{slope2} = \frac{1}{\tau_{\beta_2}}^2$$
$$\sigma_{slope3} = \frac{1}{\tau_{\beta_3}}^2$$

#Read in Data
```{r}
###Read in data
#read in flower morphology data, comes from Nectar.R
droppath<-"C:/Users/Ben/Dropbox/"
fl.morph<-read.csv(paste(droppath,"Thesis/Maquipucuna_SantaLucia/Results/FlowerMorphology.csv",sep=""))

#First row is empty
fl.morph<-fl.morph[-1,]

#Bring in Hummingbird Morphology Dataset, comes from
hum.morph<-read.csv(paste(droppath,"Thesis/Maquipucuna_SantaLucia/Results/HummingbirdMorphology.csv",sep=""))

#Bring in Interaction Matrix
int<-read.csv(paste(droppath,"Thesis/Maquipucuna_SantaLucia/Results/Network/HummingbirdInteractions.csv",sep=""),row.names=1)

m.dat<-int[colnames(int) %in% c("ID","Video","Time","Hummingbird","Sex","TransectID","Transect_R","Iplant_Double","Pierce","DateP","Month","ele","Type")]

m.dat$Year<-years(as.Date(m.dat$DateP))
#one missing date
m.dat$Year[m.dat$Year %in% 2012]<-2013

#Fix spacing to match clades

#Which are matching
levels(m.dat$Hummingbird)[!levels(m.dat$Hummingbird) %in% hum.morph$English]

#This needs to be checked
#print(paste(levels(m.dat$Hummingbird)[!levels(m.dat$Hummingbird) %in% hum.morph$English],"not matched"))

#Number of bird species
h_species<-nlevels(m.dat$Hummingbird)

#Number of plant species
plant_species<-nlevels(m.dat$Iplant_Double)

#levels(m.dat$Hummingbird)[!levels(m.dat$Hummingbird) %in% hum.morph$English]<-c("Green-crowned Woodnymph")
m.datH<-merge(m.dat,hum.morph, by.x="Hummingbird",by.y="English")

#Merge to flowers
int.FLlevels<-levels(factor(m.datH$Iplant_Double))

#Which flowers are we missing info for?
missingTraits<-int.FLlevels[!int.FLlevels %in% fl.morph$X]

#print(paste("Missing Trait Information:",missingTraits))
m.datH<-merge(m.datH,fl.morph, by.x="Iplant_Double",by.y="X")

#Drop piercing events, since they don't represent correlation
m.datH<-m.datH[!m.datH$Pierce %in% c("y","Y"),]
```

###Format data
```{r}


#remove species with less than  10 observations
keep<-names(which(table(m.datH$Hummingbird) > 20))

m.datH<-droplevels(m.datH[m.datH$Hummingbird %in% keep,])

#observed traitmatching
traitmatchF<-abs(t(sapply(hum.morph$Bill,function(x){x-fl.morph$TotalCorolla})))

rownames(traitmatchF)<-hum.morph$English
colnames(traitmatchF)<-fl.morph$Group.1
```

Format data

```{r}
#match names
#Round to 2 decimals
#Convert to cm for winbugs, avoids numerical underflow
traitmatchT<-round(traitmatchF[rownames(traitmatchF) %in% m.datH$Hummingbird,colnames(traitmatchF) %in% m.datH$Iplant_Double],2)/10
```

```{r}
#Formatting indexes
m.datH$Bird<-as.numeric(factor(m.datH$Hummingbird,sort(unique(m.datH$Hummingbird))))
m.datH$Plant<-as.numeric(factor(m.datH$Iplant_Double,sort(unique(m.datH$Iplant_Double))))
m.datH$obs<-1

traitmatchT<-traitmatchT[sort(rownames(traitmatchT)),sort(colnames(traitmatchT))]

#Create an index to connect to species names
#remerge species levels
bindex<-data.frame(Index=1:length(rownames(traitmatchT)),Species=rownames(traitmatchT))

pindex<-data.frame(Index=1:length(colnames(traitmatchT)),Species=colnames(traitmatchT))

#summarize each observeration
m.datH<-m.datH[!is.na(m.datH$ID),]

indatRaw<- m.datH %>% group_by(Bird,Plant,DateP,ID) %>% summarize(Yobs=n()) %>% ungroup() %>% arrange(desc(Yobs)) %>% mutate(Time=as.numeric(as.factor(as.character(paste(ID,DateP)))))


```


##Resource availability at each data point

```{r}

#Date organization

#read in flower totals from FlowerTransects.R
fltransects<-read.csv(paste(droppath,"Thesis/Maquipucuna_SantaLucia/Results/FlowerTransects/FlowerTransectClean.csv",sep=""))

#dates need a bit of formatting

fltransects$DateP<-as.POSIXlt(fltransects$Date,format="%d/%m/%y")

#which are NA needs to date/month reversed. ugly.
fltransects[which(is.na(fltransects$DateP)),"DateP"]<-as.character(as.POSIXlt(as.character(fltransects[which(is.na(fltransects$DateP)),"Date"]),format="%m/%d/%Y"))


#remove withour elevation records (less than 1% of data)
fltransects<-fltransects[!is.na(fltransects$ele),]

#create an initial flower interaction list
fl.sp<-split(m.datH$Iplant_Double,m.datH$Hummingbird)
fl.sp<-melt(lapply(fl.sp,function(x){unique(x)}))
colnames(fl.sp)<-c("Iplant_Double","Hummingbird")

#container to hold results

out<-list()

#get the resource availability at each time
for (y in 1:nrow(indatRaw)){
  #subset row
  x<-indatRaw[y,]

  #Date of point
  DateP<-x[["DateP"]]
  
  if(is.na(DateP)) {out[[y]]<-data.frame(Bird=x[["Bird"]],Time=x[["Time"]],AllResources=NA,PrivateResources=NA)
  next}
  
  #elevation point
  Elevation<-mean(m.datH[m.datH$ID %in% x[["ID"]],"ele"])
  
  #stop if no elevation record, as we clean more this should be fine.
  if(is.na(Elevation)) {out[[y]]<-data.frame(Bird=x[["Bird"]],Time=x[["Time"]],AllResources=NA,PrivateResources=NA)
  next}
  
  #hummingbird english name
  sp<-bindex[bindex$Index %in% x[["Bird"]],"Species"]
  
  #plant species list for that bird
  plant.list<-fl.sp[fl.sp$Hummingbird %in% sp,"Iplant_Double"]
  
  #dates within two weeks either side. 
  dateL<-abs(difftime(DateP,fltransects$DateP,units="weeks")) <= 2.5
  
  #and within 200m of the elevation
  flower.month<-fltransects[dateL & (fltransects$ele > Elevation -200 & fltransects$ele < Elevation + 200) ,]

  if(nrow(flower.month)==0) {out[[y]]<-data.frame(Bird=x[["Bird"]],Time=x[["Time"]],AllResources=NA,PrivateResources=NA)
  next}
  
  mean.fl_all<-mean(aggregate(flower.month$Total_Flowers,list(flower.month$Transect.ID),sum,na.rm=TRUE)$x)
    
  flower_sp<-flower.month[flower.month$Iplant_Double %in% plant.list,]
  
  if(nrow(flower_sp)==0) {out[[y]]<-data.frame(Bird=x[["Bird"]],Time=x[["Time"]],AllResources=NA,PrivateResources=NA)
  next}
  
  mean.fl<-mean(aggregate(flower_sp$Total_Flowers,list(flower_sp$Transect.ID),sum,na.rm=TRUE)$x)
  out[[y]]<-data.frame(Bird=x[["Bird"]],Time=x[["Time"]],AllResources=mean.fl_all,PrivateResources=mean.fl)
}

#time by resources matrix
timer<-rbind_all(out)
```

Format Data

```{r}
obs<-merge(indatRaw,timer,by=c("Bird","Time"))
#remove rows without resource information for now, need to understand why (time or space?)

obs<-obs[!is.na(obs$PrivateResources),]

#make sure there are no duplicates, needs to be evaluated
obs<-obs[!duplicated(obs),]

#scale
obs$AllResources<-scale(obs$AllResources)
```

##Hierarchical Bayesian Model

```{r,eval=T,strip.white=T}

#Source model
source("Bayesian/PoissonRagged.R")

#print model
writeLines(readLines("Bayesian/PoissonRagged.R"))

#Input Data
Dat <- list(
  Yobs=obs$Yobs,
  Nobs=nrow(obs),
  #Index of Birds
  Bird=obs$Bird,
  #Index of Plants
  Plant=obs$Plant,
  #Index of time
  Time=obs$Time,
  #Length of birds
  Birds=length(unique(obs$Bird)),
  resources=as.numeric(obs$AllResources),
  traitmatch=traitmatchT)

initY<-rep(max(obs$Yobs),length(obs$Yobs))
#Inits
InitStage <- function(){list(beta1=rep(.5,Dat$Birds),beta2=rep(.5,Dat$Birds),beta3=rep(.5,Dat$Birds),alpha=rep(.5,Dat$Birds),intercept=0,tau_alpha=0.1,tau_beta1=0.1,tau_beta2=0.1,tau_beta3=0.1,gamma1=0,gamma2=0,gamma3=0)}

#Parameters to track
ParsStage <- c("alpha","beta1","beta2","beta3","intercept","sigma_int","sigma_slope1","sigma_slope2","sigma_slope3","gamma1","gamma2","gamma3","Yobs")

#MCMC options

ni <- 50000  # number of draws from the posterior
nt <- 5  #thinning rate
nb <- ni*.5 # number to discard for burn-in
nc <- 2  # number of chains

#Jags

m = jags(inits=InitStage,
         n.chains=nc,
         model.file="Bayesian/PoissonRagged.jags",
         working.directory=getwd(),
         data=Dat,
         parameters.to.save=ParsStage,
         n.thin=nt,
         n.iter=ni,
         n.burnin=nb,
         DIC=T)
```

```{r}
pars<-extract_par(m)
```

###Assess Convergence

```{r,cache=FALSE,eval=TRUE,fig.width=11,fig.height=5}

###Chains
ggplot(pars[pars$par %in% c("alpha","beta1","beta2","beta3"),],aes(x=Draw,y=estimate,col=as.factor(Chain))) + geom_line() + facet_grid(par~species,scale="free") + theme_bw() + labs(col="Chain") + ggtitle("Detection Probability")

```

```{r,fig.height=5,fig.width=11,eval=T}
ggplot(pars[pars$par %in% c("gamma1","gamma2","gamma3","sigma_int","sigma_slope1","sigma_slope2","sigma_slope3"),],aes(x=Draw,y=estimate,col=as.factor(Chain))) + geom_line() + theme_bw() + labs(col="Chain") + ggtitle("Trait-matching regression") + facet_wrap(~par,scales="free")
```

###Posteriors

```{r,cache=FALSE,fig.width=7,fig.height=13}
###Posterior Distributions
psim<-ggplot(pars[pars$par %in% c("alpha","beta1","beta2","beta3"),],aes(x=estimate)) + geom_histogram() + ggtitle("Estimate of parameters") + facet_grid(species~par,scales="free") + theme_bw() + ggtitle("Species Posteriors")

#ggsave("Figures/ObservedPosteriors.jpg",dpi=300,height=8,width=8)
```

```{r,cache=FALSE,eval=TRUE,fig.height=13,fig.width=10}

psim2<-ggplot(pars[pars$par %in% c("gamma1","gamma2","gamma3","intercept","sigma_int","sigma_slope1","sigma_slope2","sigma_slope3"),],aes(x=estimate)) + geom_histogram() + ggtitle("Hierarchical Posteriors") + facet_wrap(~par,scale="free",nrow=2) + theme_bw() 

grid.arrange(psim,psim2,heights=c(.6,.4))
```

****
<span style="color:red; font-size=25" >True values are the dashed lines</span>

###Predicted Relationship 

```{r,fig.height=4,fig.width=4}

castdf<-group_by(pars,Chain) %>% filter(par %in% c("gamma1","gamma2","gamma3","intercept")) %>% select(par,estimate) 

castdf<-dcast(pars[pars$par %in% c("gamma1","gamma2","gamma3","intercept"),], Chain + Draw~par,value.var="estimate")

trajF<-function(alpha,beta1,beta2,beta3,x,resources){
  indat<-data.frame(alpha,beta1,beta2,beta3)
  
  #fit regression for each input estimate
  sampletraj<-list()
  
  for (y in 1:nrow(indat)){
    v=exp(indat$alpha[y] + indat$beta1[y] * x + indat$beta2[y] * resources + indat$beta3[y] * x*resources)
    
    sampletraj[[y]]<-data.frame(x=as.numeric(x),y=as.numeric(v))
  }
  
  sample_all<-rbind_all(sampletraj)
  
  #Compute CI intervals
  predy<-group_by(sample_all,x) %>% summarise(lower=quantile(y,0.025,na.rm=T),upper=quantile(y,0.975,na.rm=T),mean=mean(y,na.rm=T))
}

#calculate interactions

intF<-function(alpha,beta1,beta2,beta3,x,resources){
  indat<-data.frame(alpha,beta1,beta2,beta3)
  
  #fit regression for each input estimate
  sampletraj<-list()
  
  for (y in 1:nrow(indat)){
    v=indat$beta2[y] + indat$beta3[y]  * x
    sampletraj[[y]]<-data.frame(x=as.numeric(x),y=as.numeric(v))
  }
  
  sample_all<-rbind_all(sampletraj)
  
  #Compute CI intervals
  predy<-group_by(sample_all,x) %>% summarise(lower=quantile(y,0.025,na.rm=T),upper=quantile(y,0.975,na.rm=T),mean=mean(y,na.rm=T))
}
```

Calculated predicted y

```{r}

predy<-trajF(alpha=castdf$intercept,beta1=castdf$gamma1,x=as.numeric(traitarray),resources=resources,beta2=castdf$gamma2,beta3=gamma3)

psim3<-ggplot(data=predy,aes(x=x)) + geom_ribbon(aes(ymin=lower,ymax=upper),alpha=0.1,fill="red")  + geom_line(aes(y=mean),size=.8,col="red",linetype="dashed") + theme_bw() + ylab("Interactions") + xlab("Difference between Bill and Corolla Length") 

psim3
#ggsave("Figures/SimulationResults.jpg",height=5,width=6,dpi=300)
```

Using our model we were able to accurately capture the simulated values.

###Visualize interactions

```{r}
predyint<-intF(alpha=castdf$intercept,beta1=castdf$gamma1,x=as.numeric(traitarray),resources=resources,beta2=castdf$gamma2,beta3=gamma3)

psim4<-ggplot(data=predyint,aes(x=x)) + geom_ribbon(aes(ymin=lower,ymax=upper),alpha=0.3,fill="black") + theme_bw() + ylab("Effect of Resources on Trait Matching") + geom_line(aes(y=mean),size=.8,col="black",linetype="dashed") + xlab("Difference between Bill and Corolla Length") 

psim4
```

###Predicted Frequency

Determining model fit.

```{r,eval=F}
#this needs to be fixed, the regular expression doesn't quite match
#any given state
predState<-group_by(pars,par) %>% filter(par=="N") %>% group_by(par,species,plant) %>% summarize(State=as.numeric(names(which.max(table(estimate)))))

predState$species<-as.factor(predState$species)
predState$plant<-factor(predState$plant,levels=1:plant_species)

predplot<-ggplot(predState,aes(x=species,y=plant,fill=State)) + geom_tile() + scale_fill_continuous(na.value="white",low="white",high="red",limits=c(0,max(obs.state$Detection))) + labs(x="Hummingbird",y="Plant",fill="Predicted State") + ggtitle("Predicted") + facet_wrap(~Model)
```

###Posterior Check

Since I have simualted the data, it should fit as well as any random dataset drawn from the estimated parameters. An ideal fit would be posterior values sitting along the 1:1 line.

```{r,fig.height=4,fig.width=8,eval=F}

fitstat<-droplevels(pars[pars$par %in% c("fit","fitnew"),])
fitstat<-dcast(fitstat,Draw+Chain~par,value.var="estimate")

#add 1:1 line

ymin<-round(min(c(fitstat$fit,fitstat$fitnew)))
ymax<-round(max(c(fitstat$fit,fitstat$fitnew)))
ab<-data.frame(x=ymin:ymax,y=ymin:ymax)
p<-ggplot(fitstat,aes(x=fit,y=fitnew)) + geom_point() + theme_bw() + coord_equal()
psim5<-p  + labs(x="Discrepancy of observed data",y="Discrepancy of replicated data",col="Model") + geom_line(data=ab,aes(x=x,y=y)) + ggtitle("Simulated Data")

psim5
```


```{r}
save.image("Network.RData")
```
